{"content":[{"type":"paragraph","crDate":1770289447169,"chDate":1770290108443,"text":"Daten in JavaScript sind nie vollständig sicher, da Benutzer über die Konsole oder DevTools immer Zugriff auf Variablen haben – selbst in Modulen.\nWebWorker bieten hier einen entscheidenden Vorteil: Sie isolieren sensible Daten in einem separaten Thread, der kein DOM oder globale Objekte teilt, und erlauben nur kontrollierte Kommunikation über postMessage. Dadurch wird die Manipulation erschwert, da Daten wie Nutzerrechte oder Credits nicht direkt verändert werden können, sondern nur über definierte Aktionen. \nDennoch bleibt der Worker angreifbar, etwa durch Code-Injection oder das Abfangen von Nachrichten – serverseitige Validierung ist daher unverzichtbar. Praktisch eignen sich Worker ideal, um Client-Daten vor einfachen Angriffen zu schützen, während kritische Logik immer serverseitig abgesichert werden muss."},{"type":"paragraph","crDate":1770290118808,"chDate":1770290144567,"text":"Unten folgt eine schrittweise Anleitung, wie Daten Sicher in einem Webworker organisisert werden können."},{"type":"subheader","crDate":1770289715336,"chDate":1770290151185,"text":"1: Worker und Kommunikation"},{"type":"paragraph","crDate":1770289784025,"chDate":1770289940977,"text":"Der erste Schritt besteht darin, einen isolierten WebWorker zu erstellen, der ausschließlich definierte Nachrichten verarbeitet.\nDer Worker speichert die Nutzerdaten (z. B. Credits oder Rechte) und ein geheimes Salt, das später für die Prüfsummenberechnung verwendet wird. Die Kommunikation mit der Hauptseite erfolgt nur über postMessage, wobei ein Objekt mit Handler-Methoden die erlaubten Aktionen definiert. \nJede Nachricht wird auf eine gültige Aktion geprüft, bevor sie verarbeitet wird. Dies stellt sicher, dass der Worker nur kontrollierte Operationen ausführt und keine unerwarteten Befehle annimmt. \nDie Verwendung von async/await ermöglicht asynchrone Operationen wie das Laden von Daten oder die Berechnung von Prüfsummen, ohne den Worker zu blockieren."},{"type":"code","crDate":1770289954234,"chDate":1770291376672,"text":"// Worker\n\nlet userData = null;       // Speichert die Nutzerdaten (z. B. Credits, Rechte)\nlet SECRET_SALT = null;    // Geheimnis für Prüfsummen (wird vom Server geladen)\nlet expectedChecksum = null; // Erwartete Prüfsumme zur Validierung\n\n// Objekt mit Arrow-Functions für jede erlaubte Aktion\nconst messageHandlers = {\n\n // Initialisiert den Worker mit Salt, Daten und Prüfsumme\n init: async ({ salt, initialData, checksum }) => {\n  SECRET_SALT = salt;\n  userData = initialData;\n  expectedChecksum = checksum;\n  console.log('Worker initialisiert. Daten validiert:', await verifyData());\n },\n \n // Sendet die aktuellen Daten zurück an die Hauptseite\n getData: () => {\n  self.postMessage({ action: 'dataResponse', data: userData });\n },\n\n // Aktualisiert die Credits und berechnet eine neue Prüfsumme\n updateCredits: async ({ amount }) => {\n  if (await updateCredits(amount)) {\n   self.postMessage({\n    action: 'updateResponse',\n    success: true,\n    credits: userData.credits,\n    checksum: expectedChecksum\n   });\n  }\n }\n};\n\n// Empfängt Nachrichten von der Hauptseite\nself.addEventListener('message', async (event) => {\n const { action, payload } = event.data;\n \n // Prüft, ob die Aktion erlaubt ist, und führt die zugehörige Funktion aus\n const handler = messageHandlers[action];\n if (handler) {\n    await handler(payload);\n } else {\n  self.postMessage({ error: 'Unbekannte Aktion' });\n }\n});\n"},{"type":"subheader","crDate":1770290362225,"chDate":1770290378669,"text":"2: Salt und Daten laden"},{"type":"paragraph","crDate":1770290413146,"chDate":1770290439165,"text":"In diesem Schritt werden das Salt und die Initialdaten sicher vom Server geladen.\nDer Server generiert ein zufälliges Salt pro Session und verschlüsselt es mit einem Schlüssel, der aus der Session abgeleitet wird. Dies stellt sicher, dass das Salt nie im Klartext übertragen wird.\nGleichzeitig berechnet der Server eine Prüfsumme für die Initialdaten, die später zur Validierung der Datenintegrität verwendet wird. Die Hauptseite ruft diese Daten ab, entschlüsselt das Salt mit einem Schlüssel (z. B. aus einem Session-Cookie) und übergibt sie an den Worker. Dieser Prozess garantiert, dass weder das Salt noch die Daten während der Übertragung kompromittiert werden können."},{"type":"code","crDate":1770290391319,"chDate":1770290650140,"text":"// Node-Server\n\nconst crypto = require('crypto');\n\n// Verschlüsselt das Salt mit einem Session-Key\nconst encryptSalt = (salt, key) => {\n const cipher = crypto.createCipheriv('aes-256-cbc', key, crypto.randomBytes(16));\n return cipher.update(salt, 'utf8', 'hex') + cipher.final('hex');\n};\n\n// Berechnet die Prüfsumme für die Initialdaten\nconst calculateChecksum = (data, salt) => {\n return crypto.createHash('sha256')\n  .update(JSON.stringify(data) + salt)\n  .digest('hex');\n};\n\napp.get('/api/worker-init', (req, res) => {\n\n // 1. Salt generieren (pro Session)\n const salt = crypto.randomBytes(16).toString('hex');\n\n // 2. Initialdaten (z. B. aus der Datenbank)\n const initialData = { credits: 100, isAdmin: false };\n\n // 3. Salt verschlüsseln (mit einem Schlüssel aus der Session)\n const encryptedSalt = encryptSalt(salt, req.session.key);\n\n // 4. Prüfsumme berechnen\n const checksum = calculateChecksum(initialData, salt);\n\n res.json({ encryptedSalt, initialData, checksum });\n});\n"},{"type":"code","crDate":1770290579915,"chDate":1770290671062,"text":"// Client-JS (nicht der Worker)\n\n// Lädt die Worker-Daten vom Server\nconst loadWorkerData = async () => {\n const response = await fetch('/api/worker-init');\n const { encryptedSalt, initialData, checksum } = await response.json();\n\n // Salt entschlüsseln (z. B. mit einem Schlüssel aus dem Session-Cookie)\n const salt = await decryptSalt(encryptedSalt, sessionKey);\n\n // Worker initialisieren\n worker.postMessage({\n  action: 'init',\n  payload: { salt, initialData, checksum }\n });\n};\n"},{"type":"subheader","crDate":1770290684321,"chDate":1770290690835,"text":"3: Datenverifikation mit Prüfsumme"},{"type":"paragraph","crDate":1770290725373,"chDate":1770290767080,"text":"Um die Integrität der Daten sicherzustellen, wird eine SHA-256-Prüfsumme berechnet.\nDiese Prüfsumme kombiniert die Nutzerdaten mit dem geheimen Salt, um sicherzustellen, dass selbst kleine Änderungen an den Daten erkannt werden. \nDie Funktion calculateChecksum() erstellt einen kryptografischen Hash der Daten, während verifyData() diese Prüfsumme mit der erwarteten Prüfsumme vergleicht. Falls die Prüfsummen nicht übereinstimmen, wurden die Daten manipuliert.\nDieser Mechanismus bietet eine zusätzliche Sicherheitsebene, da jede Veränderung der Daten sofort erkannt wird."},{"type":"code","crDate":1770290706321,"chDate":1770290800755,"text":"// Berechnet die SHA-256-Prüfsumme für die Daten\nconst calculateChecksum = async (data, salt) => {\n const encoder = new TextEncoder();\n const dataString = JSON.stringify(data) + salt;\n const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(dataString));\n\n return Array.from(new Uint8Array(hashBuffer))\n  .map(b => b.toString(16).padStart(2, '0'))\n  .join('');\n};\n\n// Verifiziert die Daten anhand der Prüfsumme\nconst verifyData = async () => {\n if (!userData || !SECRET_SALT) return false;\n const currentChecksum = await calculateChecksum(userData, SECRET_SALT);\n\n return currentChecksum === expectedChecksum;\n};\n"},{"type":"subheader","crDate":1770290813839,"chDate":1770290821809,"text":"4: Daten abfragen und ändern"},{"type":"paragraph","crDate":1770290839050,"chDate":1770290898017,"text":"Um die Daten zu ändern, z. B. um Credits zu aktualisieren, sendet die Hauptseite eine Nachricht an den Worker.\nDer Worker führt die Änderung nur dann aus, wenn sie den definierten Regeln entspricht (z. B. keine negativen Credits). Nach jeder Änderung wird automatisch eine neue Prüfsumme berechnet, um die Datenintegrität zu gewährleisten. \nDie Hauptseite hat keinen direkten Zugriff auf die Daten im Worker – alle Änderungen müssen über postMessage erfolgen. Dies verhindert, dass Daten von außen manipuliert werden, ohne dass der Worker dies erkennt."},{"type":"code","crDate":1770290965379,"chDate":1770290977639,"text":"// Worker\n\n// Aktualisiert die Credits und berechnet eine neue Prüfsumme\nconst updateCredits = async (amount) => {\n if (!userData) return false;\n userData.credits += amount;\n expectedChecksum = await calculateChecksum(userData, SECRET_SALT);\n return true;\n};"},{"type":"code","crDate":1770290999242,"chDate":1770291018073,"text":"// Client-JS\n\n// Fügt Credits hinzu (z. B. nach einem Kauf)\nconst addCredits = (amount) => {\n worker.postMessage({\n  action: 'updateCredits',\n  payload: { amount }\n });\n};"},{"type":"subheader","crDate":1770290844859,"chDate":1770290853380,"text":"5: Regelmäßige Gültigkeitsprüfung"},{"type":"paragraph","crDate":1770290826426,"chDate":1770290939475,"text":"Um sicherzustellen, dass die Daten langfristig gültig bleiben, führt der Worker in regelmäßigen Abständen (z. B. alle 5 Minuten) eine automatische Überprüfung der Datenintegrität durch.\nFalls die Prüfsumme nicht mit der erwarteten Prüfsumme übereinstimmt, wird eine Warnung ausgegeben, und der Server wird benachrichtigt. Der Server kann dann Gegenmaßnahmen einleiten, z. B. die Session beenden oder die Daten zurücksetzen.\nDiese regelmäßige Überprüfung stellt sicher, dass selbst nachträgliche Manipulationen erkannt werden. Gleichzeitig wird durch die Synchronisation mit dem Server sichergestellt, dass die Daten auch serverseitig validiert werden"},{"type":"code","crDate":1770291026274,"chDate":1770291063632,"text":"// Worker.js\n\n// Prüft alle 5 Minuten die Datenintegrität\nconst validateInterval = setInterval(async () => {\n if (!(await verifyData())) {\n  self.postMessage({ error: 'Datenmanipulation erkannt!' });\n\n  // Server benachrichtigen\n  await fetch('/api/validate', {\n   method: 'POST',\n   body: JSON.stringify({ checksum: expectedChecksum })\n  });\n }\n}, 5 * 60 * 1000); // Alle 5 Minuten"},{"type":"code","crDate":1770291083921,"chDate":1770291093360,"text":"app.post('/api/validate', (req, res) => {\n const { checksum } = req.body;\n  \n // Prüfsumme mit der Datenbank abgleichen\n const isValid = validateChecksum(checksum);\n res.json({ valid: isValid });\n});"}]}