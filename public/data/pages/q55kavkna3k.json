{"content":[{"type":"paragraph","crDate":1720700174705,"chDate":1720704178437,"text":"Gelegentlich kommt es vor, dass Klassen upgedatet oder refaktoriert werden, wodurch sich das <i>Interface</i> (die Namen der Methoden und Attribute) verändert werden. Gleichzeitig kann es sein, dass nicht der gesamte Code aktualisiert werden soll, um mit dem neuen Interface umgehen zu können.. In dem Falle kann ein <i>Adapter</i> helfen, die Kommunikation mit den Objekten aufrecht zu erhalten.\nEin Adapter übersetzt Anfragen so, dass das Objekt diese Anfragen versteht. Auch wenn es intern anders aufgebaut ist."},{"type":"paragraph","crDate":1720704180742,"chDate":1720704304901,"text":"Als Beispiel eine einfache Klasse, die aufgerufen wird, um ein Argument für eine alte Funktion vor der übergabe umzuwandeln.\nIm Beispiel erwartet die Funktion die Leistung eines Fahrzeuges in PS, obwohl diese im Fahrzeug als KW gespeichert ist. Der Adapter beantwortet die Anfrage an ps() per getter und wandelt den gespeicherten Wert entsprechend um."},{"type":"code","crDate":1720704314621,"chDate":1720704537173,"text":"class OldCar {\n constructor(ps = 0) {\n  this.ps = ps;\n }\n}\n\nclass Car {\n constructor(kw = 0) {\n  this.kw = kw;\n }\n}\n\nclass CarAdapter  {\n constructor(vehicle){\n  this.vehicle = vehicle;\n }\n get ps() {\n  return Math.round(this.vehicle.kw / .73 * 10) / 10;\n }\n}\n\nconst myCar = new Car(100);\n\n// Diese Funktion erwatet ein Objekt in der alten Schreibweise\nconst oldFunction = vehicle => {\n console.log(vehicle.ps);\n}\n\n// Bei Aufruf der Funktion erzeugt der Adapter ein neues Objekt\noldFunction(new CarAdapter(myCar))"},{"type":"paragraph","crDate":1720701939131,"chDate":1720701966857,"text":"Etwas weiter gedacht kann ein Adapter auch verwendet werden, um Ergebnisse umzuwandeln."}]}