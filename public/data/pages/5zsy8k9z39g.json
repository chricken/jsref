{"content":[{"type":"paragraph","crDate":1754056690443,"chDate":1754292790549,"text":"Interfaces sind eine fortgeschrittene Möglichkeit, um die Struktur von Objekten vorzudefinieren.\nEin Interface ist in TS eine Typescript-eigene Struktur, die es in Javascript (noch) nicht gibt. Beim Kompilieren verschwindet diese Struktur. Sie prüft die Struktur also nur im Entwicklungsprozess.\nTypescript "},{"type":"paragraph","crDate":1754056903428,"chDate":1754292782730,"text":"Um ein Interface anzulegen, wird das Schlüsselwort <i>interface</i> verwendet. \nIn ihm werden die Attributnamen mit den Datentypen deklariert.\nFalls nun ein Objekt mit anderen Attributen angelegt werden soll, führt dies zu einer Fehlermeldung im Editor. Dieser markiert die Unstimmigkeit. \nIm Browser dagegen wird zur Laufzeit kein Fehler generiert."},{"type":"code","crDate":1754057136750,"chDate":1754292036365,"text":"interface Person {\n nName: string,\n vName: string,\n yearOfBirth: number\n}\n\nlet myObj: Person = {\n vName: 'Max',\n nName: 'Mustermann',\n yearOfBirth: 1990,\n location: 'Musterstadt'  // -> Fehlermeldung im Editor aber nicht zur Laufzeit\n}\n\nconsole.log(myObj);"},{"type":"subheader","crDate":1754293025090,"chDate":1754293030345,"text":"Vererbung"},{"type":"paragraph","crDate":1754293032951,"chDate":1754293419300,"text":"Interfaces können, ähnlich wie Klassen, vererbt werden. Dadurch lassen sich komplexe modulare Strukturen aufbauen."},{"type":"code","crDate":1754293134178,"chDate":1754293160581,"text":"interface Person {\n nName: string,\n vName: string,\n yearOfBirth: number\n}\n\ninterface Employee extends Person {\n maNumber: string,\n location: string,\n}\n\nlet myObj: Employee = {\n vName: 'Max',\n nName: 'Mustermann',\n yearOfBirth: 1990,\n location: 'Musterhausen',\n maNumber: '123456789'\n}\n\nconsole.log(myObj);"},{"type":"subheader","crDate":1754293570081,"chDate":1754293575191,"text":"readonly"},{"type":"paragraph","crDate":1754293579013,"chDate":1754293852529,"text":"Attribute können mit dem <i>readonly</i>-Attribut schreibgeschützt werden.\nFalls im Code versucht wird, das Attribut zu überschreiben, wird dies als Fehler markiert."},{"type":"code","crDate":1754293870327,"chDate":1754293904210,"text":"interface Employee {\n readonly maNumber: string,\n nName: string,\n vName: string,\n}\n\nlet ma: Employee = {\n maNumber: '123456789',\n vName: 'Max',\n nName: 'Mustermann',\n}\n\nma.maNumber = '987654321';  // -> Fehlermeldung\n\nconsole.log(ma);"},{"type":"subheader","crDate":1754294519085,"chDate":1754294542559,"text":"Type Alias"},{"type":"paragraph","crDate":1754294526110,"chDate":1754302459932,"text":"Ein Type Alias ist etwas einfacher und flexibler als Interfaces. \nSie nehmen einen bestehenden Datentypen (auch Primitives, Interfaces und anderes) und geben ihm einen Namen.\nType Aliase erlauben auch alternative Inhalte, die mit einem | verknüpft werden."},{"type":"code","crDate":1754302462942,"chDate":1754302471791,"text":"type UserID = string;\ntype Point = { x: number; y: number };\ntype Res = 'success' | 'error';\n\nlet id: UserID = 'abcd1234';\nlet myPt: Point = {x: 12, y: 34};\n\nconst res1: Res = 'success';\nconst res2: Res = 'error';\n\nconsole.log(id);\nconsole.log(myPt);\nconsole.log(res1);\nconsole.log(res2);"}]}