{"content":[{"type":"paragraph","crDate":1715088692476,"chDate":1715088815970,"text":"Das Kopieren einer Datensammlung erzeugt eine <i>Shallow Copy</i>. Das bedeutet, dass die neue Datensammlung zwar keine Referenz des Originals ist. Jedes Attribut der Datensammlung ist aber weiterhin eine Referenz."},{"type":"code","crDate":1715088902641,"chDate":1715089397495,"text":"const data = [{\n a: 1,\n b: 2,\n arr: [21, 54, 87]\n}]\n\nlet clone = [...data];\ndata[0].a = 100;\n\nconsole.log(data[0].a);   // -> 100\nconsole.log(clone[0].a);  // -> 100"},{"type":"subheader","crDate":1715088689969,"chDate":1715090485627,"text":"JSON"},{"type":"paragraph","crDate":1715088949283,"chDate":1715089335335,"text":"Die einfachste Lösung dieses Problems ist eine Deep Copy per JSON. Durch das Umwandeln der Datensammlung in einen JSON-.String löst jede Referenz unweigerlich auf. Die Rückumwandlung zu einem Array/Objekt erzeugt die Struktur neu.\nDiese Technik ist gut und hilfreich, solange die Datensammlung nur aus Elementen besteht, die von JSON unterstützt werden. Methoden, Maps und Sets dagegen werden nicht berücksichtigt."},{"type":"code","crDate":1715089364383,"chDate":1715089388972,"text":"const data = [{\n a: 1,\n b: 2,\n arr: [21, 54, 87]\n}]\n\nlet clone = JSON.parse(JSON.stringify(data));\ndata[0].a = 100;\n\nconsole.log(data[0].a);\nconsole.log(clone[0].a);"},{"type":"subheader","crDate":1715091020920,"chDate":1715091062338,"text":"Custom Function"},{"type":"paragraph","crDate":1715091065837,"chDate":1715091311503,"text":"Wenn der zu kopierende Datensatz Maps, Sets oder Methoden enthält, muss ein besserer Weg gefunden werden, um eine Deep Copy anzulegen. Eine rekursive Funktion kann Verschachtelungen in beliebiger Tiefe verfolgen und auf jeden Datentypen passend reagieren."},{"type":"code","crDate":1715091482342,"chDate":1715091608246,"text":"const deepCopy = obj => {\n if (obj instanceof Map) {\n  const copy = new Map();\n  obj.forEach((value, key) => {\n   copy.set(deepCopy(key), deepCopy(value));\n  });\n  return copy;\n }\n\n if (obj instanceof Set) {\n  const copy = new Set();\n  obj.forEach((value) => {\n   copy.add(deepCopy(value));\n  });\n  return copy;\n }\n\n if (typeof obj === 'function') {\n  return obj;\n }\n\n if (typeof obj === 'object' && obj !== null) {\n  const copy = Array.isArray(obj) ? [] : {};\n  for (const key of Object.keys(obj)) {\n   copy[key] = deepCopy(obj[key]);\n  }\n  return copy;\n }\n\n return obj;\n}\n\nlet myMap = new Map([['x', 12], ['y', 23], ['z', 34]]);\n\nconst data = [{\n a: 1,\n b: 2,\n m: myMap,\n myMethod() { console.log('Ich bin eine Methode') }\n}]\n\nlet clone = deepCopy(data);\ndata[0].a = 100;\n\nconsole.log(data);\nconsole.log(clone);"}]}