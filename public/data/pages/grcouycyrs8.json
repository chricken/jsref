{"content":[{"type":"paragraph","crDate":1771428228862,"chDate":1771428813313,"text":"Der useReducer-Hook erlaubt es, Daten immutable zu verwalten. Durch seine Struktur ist er besser als <i>useState</i> geeignet, um komplexe Daten und komplexe Logik zu verwalten. In der Komplexität und der Art der Anwendung steht <i>useReducer</i> damit zwischen <i>useContext</i> und <i>Redux</i>\nUm den useReducer-Hook zu verstehen, müssen zunächst ein paar Begriffe in diesem Zusammenhang geklärt werden:"},{"type":"subheader","crDate":1771428728337,"chDate":1771428732261,"text":"Action"},{"type":"paragraph","crDate":1771428743622,"chDate":1771431737583,"text":"Wunsch, der an einen Reducer übertragen wird. Die Action enthält alle Informationen, um den Reducer zu steuern.\nEine Action ist ein einfaches JS-Objekt, das mindestens ein <i>type</i>-Attribut hat. Dieses enthält die Information, was der Reducer machen soll.\nNeben dem type kann eine Action beliebige weitere Attribute enthalten.\n<b>Wichtig</b>: Die Action enhält nur reine Daten, keine Logik\n<b>Wichtig</b>: Die Schreibweise für den Type (\"Screaming Snake\") ist verpflichtend."},{"type":"code","crDate":1771429225506,"chDate":1771429267277,"text":"// Eine typische Struktur für eine Action\n{\n  type: 'ACTION_TYPE',       // Pflicht: Beschreibt, WAS passieren soll (z. B. \"ADD_ITEM\").\n  payload: Nutzdaten,        // Optional: Daten, die für die Aktualisierung benötigt werden.\n  meta: Zusatzinformationen  // Optional: Metadaten (z. B. Timestamp, Error-Details).\n}"},{"type":"subheader","crDate":1771428759118,"chDate":1771428767610,"text":"Reducer"},{"type":"paragraph","crDate":1771428777667,"chDate":1771431848661,"text":"Der Reducer empfängt einen State und eine Action.\nDie Action wird analysiert und der State daraufhin verändert. Der Reducer gibt den veränderten State wieder zurück.\nDer Reducer ist das einzige Element, der die Daten tatsächlich verändert, dadurch wird eine Entkopplung zwischen den Datenverwaltung und der Benutzerebene erreicht."},{"type":"code","crDate":1771431785804,"chDate":1771432013056,"text":"const dummyReducer = (state, action) => {\n if(action.type === 'DO_THIS') {\n  // etwas am State ändern\n  return state\n } else if(action.type === 'DO_THAT') {\n  // etwas am State ändern\n  return state\n } else {\n  return state\n }\n};"},{"type":"subheader","crDate":1771432234805,"chDate":1771432244756,"text":"useReducer"},{"type":"paragraph","crDate":1771432247149,"chDate":1771432401932,"text":"Der <i>useReducer</i>-Hook verbindet dann all diese Elemente.\nDer Hook bekommt zwei Parameter übergeben: \n<ul>\n<li>Den Reducer</li>\n<li>Den initialen Wert</li>\n</ul>\nund er liefert ein Array aus zwei Wertemn zurück:\n<ul>\n<li>Den State</li>\n<li>Die Dispatch-Funktion</li>\n</ul>"},{"type":"code","crDate":1771432425678,"chDate":1771432461850,"text":"const [myState, myDispatch] = useReducer(dummyReducer, 0);"},{"type":"subheader","crDate":1771428788194,"chDate":1771428790783,"text":"Dispatch"},{"type":"paragraph","crDate":1771428799603,"chDate":1771432535867,"text":"dispacth() sendet schließlich eine Action an den Reducer."},{"type":"code","crDate":1771432140573,"chDate":1771432470427,"text":"&lt;button onClick={ () => myDispatch({ type: 'DO_THIS' }) }>\nExecute\n&lt;/button>"},{"type":"subheader","crDate":1771433131288,"chDate":1771433139416,"text":"Beispiel: Counter"},{"type":"paragraph","crDate":1771433145032,"chDate":1771433438083,"text":"Für den Counter brauchen wir einen Reducer, der den Wert hoch- und herunterzählt.\nDazu legen wir einen Reducer an, was nichts anderes ist als eine Funktion, die zwei Parameter erwartet: Einen State (den Wert) und eine Action (siehe oben).\nIn der Reducer-Funktion wird dann geschaut, welche Aktion gewünscht wird und anhand eine <i>if</i>-Verkettung ausgeführt.\nIm Beispiel soll \"INKREMENT\" den Counter hochzählen, \"DEKREMENT\" zählt ihn herunter, \"RESET\" setzt den Counter auf 0 zurück.\nWichtig ist dabei, zu beachten, dass nicht der State verändert, sondern der <i>neue Wert zurückgegeben</i> wird.\n"},{"type":"code","crDate":1771433474123,"chDate":1771433512281,"text":"const countReducer = (state, action) => {\n if (action.type === 'INCREMENT') {\n  return state + 1;\n } else if (action.type === 'DECREMENT') {\n  return state - 1;\n } else if (action.type === 'RESET') {\n  return 0;\n } else {\n  return state;\n }\n}"},{"type":"paragraph","crDate":1771433529444,"chDate":1771433694416,"text":"Im nächsten Schritt legen wir unsere Datenstruktur an.\nDazu verwenden wir den <i>useReducer</i>-Hook. Dieser legt den <i>State</i> an und stellt die <i>dispatch</i>-Funktion bereit, um den Reducer aufzurufen.\n"},{"type":"code","crDate":1771433700524,"chDate":1771433742616,"text":"import {useReducer} from 'react'\n\nconst countReducer = (state, action) => {\n // Reducer-Code (siehe oben\n}\n\nconst Counter = () => {\n const [count, dispCount] = useReducer(countReducer, 0);\n}\n\nexport default Counter"},{"type":"paragraph","crDate":1771433761253,"chDate":1771433901087,"text":"Schließlich brauchen wir noch den Aufruf des Reducers über die <i>dispatch</i>-Funktion (dispatch deutsch: \"Absenden\").\nWir wollen diese einfach über Buttons absenden. Also gestalten wir für jeden Button eine Action und senden sie ab. \nIn diesem einfachen Beispiel enthält die Action nur den Type, sie kann aber auch wesentlich ausgefeilter sein.\nUnten der gesamte Code."},{"type":"code","crDate":1771433903361,"chDate":1771433985068,"text":"import {useReducer} from 'react'\n\nconst countReducer = (state, action) => {\n if (action.type === 'INCREMENT') {\n  return state + 1;\n } else if (action.type === 'DECREMENT') {\n  return state - 1;\n } else if (action.type === 'RESET') {\n  return 0;\n } else {\n  return state;\n }\n}\n\nconst Counter = () => {\n const [count, dispCount] = useReducer(countReducer, 0);\n\n return (\n  &lt;>\n   &lt;div className={'counter'}>\n    &lt;button onClick={() => dispCount({type: 'DECREMENT'})}>-&lt;/button>\n    {count}\n    &lt;button onClick={() => dispCount({type: 'INCREMENT'})}>+&lt;/button>\n    &lt;button onClick={() => dispCount({type: 'RESET'})}>0&lt;/button>\n   &lt;/div>\n  &lt;/>\n )\n}\n\nexport default Counter"},{"type":"subheader","crDate":1771434005905,"chDate":1771434016489,"text":"Counter erweitern: Wert festlegen"},{"type":"paragraph","crDate":1771434020295,"chDate":1771434495166,"text":"Um den einfachen Counter interessanter zu gestalten, fügen wir eine Möglichkeit ein, den Counter auf einen festen Wert zu setzen.\nDazu muss der neue Wert an den Reducer übergeben werden. Das erledigen wir über das Payload-Attribut. Der Name ist dabei beliebig, \"payload\" ist aber üblich und daher sinnvoll.\nZunächst brauchen wir eine weites else-if-statement, um auf die neue Action zu reagieren.\nWir nennen sie SET_VALUE."},{"type":"code","crDate":1771434512803,"chDate":1771434552942,"text":"const countReducer = (state, action) => {\n if (action.type === 'INCREMENT') {\n  // ... Hier sind die anderen Actions\n } else if (action.type === 'SET_VALUE') {\n  return action.payload\n } else {\n  return state;\n }\n}"},{"type":"paragraph","crDate":1771434565058,"chDate":1771434619126,"text":"Dann brauchen wir einen neuen Dispatcher, der die Action zum Reducer sendet, um die Änderung herbeizuführen.\n"},{"type":"code","crDate":1771434648850,"chDate":1771434728123,"text":"dispCount({\n type: 'SET_VALUE',\n payload: someValue\n})"},{"type":"paragraph","crDate":1771434665861,"chDate":1771434759259,"text":"Hier der vollständige Code für die erweiterte Komponente.\nBitte beachte, dass auch eine Eingabe benötigt wird, um einen neuen Wert zur Verfügung zu stellen.\nFür die Eingabe wurde ein weiterer State zur Verfügung gestellt."},{"type":"code","crDate":1771434763995,"chDate":1771434846934,"text":"import {useReducer, useState} from 'react'\n\nconst countReducer = (state, action) => {\n if (action.type === 'INCREMENT') {\n  return state + 1;\n } else if (action.type === 'DECREMENT') {\n  return state - 1;\n } else if (action.type === 'RESET') {\n  return 0;\n } else if (action.type === 'SET_VALUE') {\n  return action.payload\n } else {\n  return state;\n }\n}\n\nconst Counter = () => {\n const [count, dispCount] = useReducer(countReducer, 0);\n const [inpValue, setInpValue] = useState(42);\n \n const handleChange = evt => {\n  setInpValue(evt.target.value);\n  dispCount({\n   type: 'SET_VALUE',\n   payload: evt.target.value\n  })\n }\n\n return (\n  &lt;>\n   &lt;div className={'counter'}>\n    &lt;p>\n     &lt;input value={inpValue} onChange={handleChange}/>\n    &lt;/p>\n    &lt;button onClick={() => dispCount({type: 'DECREMENT'})}>-&lt;/button>\n    {count}\n    &lt;button onClick={() => dispCount({type: 'INCREMENT'})}>+&lt;/button>\n    &lt;button onClick={() => dispCount({type: 'RESET'})}>0&lt;/button>\n   &lt;/div>\n  &lt;/>\n )\n}\n\nexport default Counter"}]}