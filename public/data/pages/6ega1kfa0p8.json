{"content":[{"type":"paragraph","crDate":1758722583837,"chDate":1758806004426,"text":"Custom Hooks sind eine Möglichkeit, wiederverwendbare Logik für Komponenten zu erstellen. \nIm Gegensatz zu normalen Funktionen erlauben sie die Verwendung von Hooks wie <i>useState</i> oder <i>useEffect</i>. Damit lassen sich häufig genutzte Abläufe oder Zustände auslagern und sauber strukturieren.\nAnstatt denselben Code immer wieder in verschiedenen Komponenten zu schreiben, kann man einen Custom Hook erstellen und diesen überall einsetzen.\nTypische Anwendungsfälle sind z.B. das Verwalten von Formularzuständen, das Abrufen von Daten oder das Verarbeiten von Benutzerinteraktionen.\nIm Folgenden soll an einem Beispiel erklärt werden, wie eine CustomHook erstellt und eingebunden wird."},{"type":"subheader","crDate":1758806011172,"chDate":1758806016049,"text":"Der customHook"},{"type":"paragraph","crDate":1758805617826,"chDate":1758809085598,"text":"Es wurde eine Datei angelegt mit Namen <i>useLoadJSON.js</i>. Der Name muss immer mit <i>use</i> beginnen. \nDies ist mit dem folgenden Code gefüllt. \nErläuterung des Beispiels:\nZunächst werden die Standard-Hooks <i>useEffect</i> und <i>useState</i> importiert, die in dieser Funktion benötigt werden.\nDann wird eine Funktion mit dem gewünschten Namen des Hook angelegt, die am Ende exportiert wird.\n<br>\nSo viel zu den Gemeinsamkeiten aller custom Hooks, der restliche Inhalt des Hook ist individuell unterschiedlich, je nach Zweck.\nIm Folgenden wird dieses eine Beispiel erklärt, um den Code und die Zusammenhänge hier zu verstehen.\nZunächst werden drei <i>States</i> für die möglichen Zustände des Ladevorganges bereitgestellt. \n<i>data</i> wird die Daten enthalten, sobald sie geladen sind.\n<i>loading</i> enthält die Information, ob der Ladevorgang noch läuft. \nUnd <i>error</i> enthält mglw. eine Fehlermeldung.\n<br>\nSobald der Hook eingebunden ist, wird der <i>useEffect()</i>-Hook gefeuert. Die <i>fetch()</i>-Methode lädt die URL als JSON und gibt das Ergebnis in der <i>then()-Chain</i> weiter.\nWenn der Ladevorgang erfolgreich war (letztes then()), dann wird der Inhalt in den <i>data</i>-State geschrieben. Loading wird auf false gesetzt, um zu zeigen, dass der Ladevorgang abgeschlossen ist.\nWenn es einen Fehler gab (<i>if (!response.ok)</i>, wird mittels <i>throw()</i> die <i>catch()</i>-Methode aufgerufen.\nIn dieser wird der gewirfene Fehler in den <i>error</i>-State geschrieben. Und auch hier wird der Ladevorgang als abgeschlossen gesetzt.\n<br>\nSchließlich werden die drei <i>States</i> in einem Objekt zusammengefasst zurückgegeben."},{"type":"code","crDate":1758806115583,"chDate":1758808988526,"text":"import {useEffect, useState} from 'react'\n\nconst useLoadJSON = (url) => {\n const [data, setData] = useState(null)\n const [loading, setLoading] = useState(true)\n const [error, setError] = useState(null)\n\n useEffect(() => {\n  \n  fetch(url).then(response => {\n   if (!response.ok) throw new Error(`HTTP-Fehler! Status: ${response.status}`)\n   return response.json()\n  }).then(jsonData => {\n   setData(jsonData)\n   setLoading(false)\n  }).catch(err => {\n   setError(err)\n   setData(null)\n   setLoading(false)\n  })\n\n }, [url])\n\n return {data, loading, error}\n}\n\nexport default useLoadJSON"},{"type":"subheader","crDate":1758723326270,"chDate":1758809204439,"text":"Einbindung in Komponenten"},{"type":"paragraph","crDate":1758809207626,"chDate":1758810105910,"text":"Um den Custom Hook in eine Komponente einzubinden muss die Datei importiert werden.\nIn der Komponente wird die importierte <i>useLoadJSON()</i>-Funktion aufgerufen. Der Rückgabewert ist ein Objekt mit den States aus dem Hook. Diese States werden per <i>Destructuring</i> in Variablen geschrieben, welche in der Komponente verwendet werden können."},{"type":"code","crDate":1758809764896,"chDate":1758810126646,"text":"import useLoadJSON from './hooks/useLoadJSON.js'\n\nconst App = () => {\n const {data, loading, error} = useLoadJSON('/data.json')\n\n if (loading) return &lt;p>Lade Daten...&lt;/p>\n if (error) return &lt;p style={{color: 'red'}}>Fehler: {error.message}&lt;/p>\n\n return (\n  &lt;>\n   &lt;h1>{data.length} Datensätze&lt;/h1>\n   {data.map((element, index) =>\n    &lt;p key={index}>{element.content}&lt;/p>\n   )}\n  &lt;/>\n )\n}\n\nexport default App"}]}