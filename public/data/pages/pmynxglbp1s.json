{"content":[{"type":"paragraph","crDate":1692619375734,"chDate":1692619866498,"text":"Der Intersection-Observer beobachtet eine Liste von DOM-Elementen. Sobald diese in den Viewport gescrollt werden oder diesen verlassen, wird die Callback-Funktion gefeuert.\nDas Anlegen einer Intersection-Observers erfolgt in vier Schritten."},{"type":"subheader","crDate":1692619899153,"chDate":1692619907407,"text":"Handler"},{"type":"paragraph","crDate":1692619911384,"chDate":1692620231456,"text":"Der <i>Handler</i> bzw. die <i>Callback()</i>-Funktion ist das erste Element, das angelegt werden sollte. \nDieser Handler wird später von Observer aufgerufen und ihm wird eine Liste von Objekten übergeben."},{"type":"code","crDate":1692620291521,"chDate":1692620296475,"text":"const intersectionHandler = entries => {\n entries.forEach(entry => {\n  console.log(entry);\n })\n}\n"},{"type":"subheader","crDate":1692620235809,"chDate":1692620289292,"text":"Observer"},{"type":"paragraph","crDate":1692620302475,"chDate":1692620334440,"text":"Der Observer steuert die gesamte Handlung. Er beobachtet die Elemente und feuert ggf den Handler."},{"type":"code","crDate":1692620344112,"chDate":1692620345634,"text":"const myObserver = new IntersectionObserver(intersectionHandler);"},{"type":"subheader","crDate":1692620353616,"chDate":1692620363759,"text":"Elemente selektieren"},{"type":"paragraph","crDate":1692620367390,"chDate":1692620386917,"text":"Durch die Selektion der Elemente wird bestimmt, welche Elemente beobachtet werden sollen."},{"type":"code","crDate":1692620397237,"chDate":1692620398940,"text":"const elements = document.querySelectorAll('section');"},{"type":"subheader","crDate":1692620403068,"chDate":1692620411499,"text":"Zuweisen des Observers"},{"type":"paragraph","crDate":1692620416193,"chDate":1692620498869,"text":"Als letzten Schritt wid für jedes zu beobachtende DOM-Element die <i>observe()</i>-Methode des Observers aufgerufen werden.\nDie Methode bekommt das DOM-Element als Parameter übergeben und von da an wird das Element beobachtet."},{"type":"code","crDate":1692620506196,"chDate":1692620509588,"text":"elements.forEach(element => {\n myObserver.observe(element);\n})"},{"type":"subheader","crDate":1692620550834,"chDate":1692620554629,"text":"IntersectionObserverEntry"},{"type":"paragraph","crDate":1692620559824,"chDate":1692620814407,"text":"Der Handler bekommt ein Array von <i>IntersectionObserverEntrys</i> übergeben. Diese können im Handler verarbeitet werden. Es werden nur die Objekte übergeben, für die sich tatsächlich eine Änderung ergeben hat.\nDiese Objekte enthalten unter anderem die folgenden Attribute:\n<b>target: </b>\nDas DOM-Element, dessen Zustand sich geändert hat\n<b>isIntersecting</b>\nBoolean, das aussagt, ob das DOM-Element im sichtbaren Bereich befindet oder nicht.\n"},{"type":"subheader","crDate":1692620880586,"chDate":1692620889273,"text":"unobserve()"},{"type":"paragraph","crDate":1692620894568,"chDate":1692620925990,"text":"Mit der <i>unobserve()</i>-Methode kann das Beobachten eines individuellen DOM-Elementes beendet werden."},{"type":"code","crDate":1692620993962,"chDate":1692620999585,"text":"myObserver.unobserve(element);"},{"type":"subheader","crDate":1692621039132,"chDate":1692621044550,"text":"Optionen"},{"type":"paragraph","crDate":1692621049549,"chDate":1692621726372,"text":"Der Intersection-Observer kann durch zusätzliche Optionen gesteuert werden. Die Optionen werden dem <i>IntersectionObserver()</i>-Constructor übergeben.\n<b>root</b>\nDas Objekt, dessen Grenzen als die des Viewports für das Element behandelt werden. Wenn die <i>root</i> null ist, werden die Grenzen des tatsächlichen Dokument-Viewports verwendet.\n<b>rootMargin</b>\nHiermit können die Grenzen des Viewport verschoben werden. Je höher der Wert, desto weiter außen reagiert der Observer. Es können auch negative Werte vergeben werden.\nDie Eingabe kann als einzelner Wert erfolgen, der dann für alle vier Kanten angenommen wird. Oder es können im Stile von CSS alle vier Kanten im Uhrzeigersinn angegeben werden.\n<b>threshold</b>\nEin Wert zwischen 0 und 1, der angibt, wieviel von dem Element sichtbar sein muss, damit der Observer reagiert."},{"type":"code","crDate":1692621803648,"chDate":1692621809759,"text":"const options = {\n rootMargin: '-100px',\n threshold: .1\n}\n"},{"type":"header","crDate":1692621830414,"chDate":1692621836367,"text":"Alles zusammen"},{"type":"paragraph","crDate":1692621838805,"chDate":1692621853396,"text":"Der gesamte in einem einfachen Beispiel könnte dann so aussehen:"},{"type":"code","crDate":1692621855836,"chDate":1692621961398,"text":"const intersectionHandler = entries => {\n entries.forEach(entry => {\n  console.log(entry.target);\n })\n}\n\nconst options = { rootMargin: '-100px' };\n\nconst myObserver = new IntersectionObserver(intersectionHandler, options);\n\nconst elements = document.querySelectorAll('section');\n\nelements.forEach(el => myObserver.observe(el));"}]}