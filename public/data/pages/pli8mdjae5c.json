{"content":[{"type":"paragraph","crDate":1753788560997,"chDate":1753791188036,"text":"React erlaubt es, auch eigene Hooks zu entwickeln. Diese sehen auf den ersten Blick aus wie eine Funktion, die in ein Modul ausgelagert wurde. \nEs steckt aber mehr dahinter:\nEin customHook kennt den Zustand der Komponente. Dadurch ist es ihm erlaubt, React-eigene Hooks (useState, etc) zu verwenden. \nEin customHook muss immer mit <i>use</i> beginnen, sonst erzeugt React einen Fehler."},{"type":"paragraph","crDate":1753791169820,"chDate":1753791611623,"text":"Dadurch sind customHooks sehr praktisch, um wiederkehrende Aufgaben, die Hooks benötigen, in Modulen zu organisieren.\nEin gutes Beispiel dafür ist das Laden von Ressourcen mit <i>fetch()</i>.\nIm Code unten ist der <i>customHook</i> zu sehen. Dieser hat einige States, um die Zustände (loading, error, etc) zu verwalten.\nDann wird in einem eigenen Effect-Hook der Ladeprozess angestoßen. Sobald die Daten geladen sind, liegen diese im payload-State.\nFalls es einen Fehler gibt, wird der err-State mit Inhalt gefüllt.\nAm Ende wird auf jeden Fall die loading-Eigenschaft auf false gesetzt, damit das Ergebnis auch sichbar ist."},{"type":"code","crDate":1753791617552,"chDate":1753791699519,"text":"import { useState } from \"react\";\nimport { useEffect } from \"react\";\n\nconst useFetch = (url) => {\n let [payload, setPayload] = useState(null);\n let [err, setErr] = useState(null)\n let [loading, setLoading] = useState(true)\n useEffect(() => {\n  // setTimeout, um die Anzeige des Ladetextes zu testen\n  // setTimeout(() => {\n   // URL aufrufen\n   fetch(url).then(\n    res => res.json()\n   ).then(\n    // geladene Daten in payload übertragen\n    res => setPayload(res)\n   ).catch(\n    // Fehler in err übertragen\n    res => setErr(res)\n   ).finally(\n    // Am Ende den Lade-Status auf false setzen\n    () => setLoading(false)\n   )\n   // }, 2000)\n  }, \n [])\n\n return { payload, err, loading };\n}\n\nexport default useFetch;"},{"type":"paragraph","crDate":1753791705088,"chDate":1753791825422,"text":"Beim Einbinden der customHook wird das Objekt destrukturiert, um auf die einzelnen Eigenschaften zugreifen zu können.\nDer Hook bekommt die zu ladende URL übergeben.\nWenn sich etwas am Zustand im Hook ändert, ist dies soroft zu sehen."},{"type":"code","crDate":1753791870935,"chDate":1753791967139,"text":"import useFetch from './useFetch';\n\nconst App = () => {\n let { payload, err, loading } = useFetch('/data.json')\n\n const getLoadedData = () => {\n  if (loading) return &lt;p>Loading ...&lt;/p>\n  else if (err) return &lt;p>Hoppala, ein Fehler&lt;/p>\n  else {\n   return (\n    &lt;>\n     &lt;p>{payload.content}&lt;/p>\n    &lt;/>\n   )\n  }\n }\n\n return (\n  &lt;>\n   &lt;h1>Test customHook&lt;/h1>\n   &lt;div className=\"loadedData\">\n    {getLoadedData()}\n   &lt;/div>\n  &lt;/>\n )\n}\n\nexport default App;"}]}