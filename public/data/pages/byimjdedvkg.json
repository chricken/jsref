{"content":[{"type":"paragraph","crDate":1689146267272,"chDate":1689159545217,"text":"Eine Route (oder Routenhandler) in Express.js ist eine Kombination aus einer <i>URL</i>, einer <i>HTTP-Methode</i> (GET, POST, PUT, DELETE usw.) und einer oder mehrerer <i>Callback-Funktionen</i>, die die Anforderung bearbeiten und eine Antwort senden. Routen sind der Weg, wie eine Express-Anwendung auf Client-Anforderungen reagiert. \nEine Route startet ihre Callback-Funktion, wenn die richtige </i>URL</i> mit der richtigen <i>Methode</i> (siehe Thema </i>Ajax</i>) aufgerufen wird.\nDie Handler-Funktion nimmt zwei Argumente an: ein Anforderungsobjekt, das Informationen über die Client-Anforderung enthält. Und ein Antwortobjekt, das Methoden zum Senden der Antwort an den Client enthält.\nDiese Parameter sind dieselben Objekte, welche vorher von der Middleware verarbeitet wurde. D.h., alle Änderungen, die eine Middleware an diesen Objekten vorgenommen hat, sind auch hier in diesen Objekten zu finden.\nAls Beispiel hier ein einfaches Server-Script, das auf eine Anfrage mit \"Hallo Welt\" antwortet."},{"type":"code","crDate":1689146533552,"chDate":1689146854550,"text":"import express from 'express';\nconst server = express();\n\nserver.get('*', (req, res) => {\n res.send('Default-Seite');\n});\n\nserver.listen(8000, err => console.log(err || 'Server läuft'));"},{"type":"paragraph","crDate":1689146553941,"chDate":1689146630503,"text":"Üblicherweise wird vor den Routen noch eine Middleware eingebunden, welche die statische Dateien ausliefert."},{"type":"code","crDate":1689146746214,"chDate":1689146861877,"text":"import express from 'express';\nconst server = express();\n\nserver.use(express.static('public'));\n\nserver.get('*', (req, res) => {\n res.send('Default-Seite');\n});\n\nserver.listen(8000, err => console.log(err || 'Server läuft'));\n"},{"type":"paragraph","crDate":1689147055441,"chDate":1689160442588,"text":"Der Aufruf geschieht durch die Kombination der Methode und der URL.\nHier ein etwas interessanteres Server-Script, welches eine Middleware enthält, die das Request-Objekt manipuliert.\nDie Manipulation wird in einer weiter unten liegenden Route ausgelesen und an den Client gesendet.\nEine andere Route bekommt zwei Zahlen übergeben und gibt das Produkt der beiden zurück."},{"type":"code","crDate":1689157085257,"chDate":1689158070389,"text":"// SERVER\n\nimport express from 'express';\nconst server = express();\n\nserver.use((req, res, next) => {\n req.someChange = 'Hello World';\n next();\n})\n\n// Wird benötigt, um die Daten aus der post-Anfrage bereitzustellen\nserver.use(express.json());\n\nserver.use(express.static('public'));\n\n// Einfache get-Route\nserver.get('/anfrage', (req, res) => {\n // Antwort senden\n res.send(req.someChange);\n})\n\n// post-Route, die zwei Zahlen multipliziert und das Ergebnis zurücksendet\nserver.post('/multiply', (req, res) => {\n // Antwort senden\n let result = req.body.x * req.body.y;\n res.json({\n  x: req.body.x,\n  y: req.body.y,\n  result\n });\n})\n\nserver.listen(8000, err => console.log(err || 'Server läuft'));\n"},{"type":"code","crDate":1689157875686,"chDate":1689160465133,"text":"// CLIENT\n\nfetch('/anfrage')  // Ohne angegebene Methode wird GET verwendet\n .then(res => res.text())\n .then(console.log)\n .catch(console.warn)\n\nfetch('/multiply', {\n method: 'post',\n headers: { 'content-type': 'application/json' },\n body: JSON.stringify({\n  x: ~~(Math.random() * 100),\n  y: ~~(Math.random() * 100)\n })\n})\n .then(res => res.json())\n .then(console.log)\n .catch(console.warn)"},{"type":"subheader","crDate":1689147091197,"chDate":1689147097005,"text":"Routen kombinieren"},{"type":"paragraph","crDate":1689160790685,"chDate":1689160917377,"text":"Eine Route kann auch mehrere Callback-Funktionen erhalten.\nDiese Callback-Funktionen müssen einander, ähnlich der Middlewares, mit der <i>next()</i>-Funktion aufrufen."},{"type":"code","crDate":1689160793313,"chDate":1689160808345,"text":"server.get('/anfrage', (req, res, next) => {\n console.log('Erste Funktion');\n next();\n}, (req, res, next) => {\n console.log('Zweite Funktion');\n next();\n}, (req, res) => {\n console.log('Dritte Funktion');\n res.send('Hallo vom /beispiel Pfad!');\n});"},{"type":"subheader","crDate":1689161882753,"chDate":1689161889303,"text":"Routen importieren"},{"type":"paragraph","crDate":1689161893383,"chDate":1689163467698,"text":"Um viele Routen besser organisieren zu können bietet es sich an, diese in einem eigenen Modul anzulegen und in den Server zu importieren.\nIn dem Modul werden mithilfe der <i>Router()</i>-Methode mehrere Routen angelegt und exportiert.\nDiese können dann an eine Eltern-Route angehängt werden. "},{"type":"code","crDate":1689163285875,"chDate":1689163318232,"text":"// calcRoutes.js\n\nimport express from 'express';\nconst router = express.Router();\n\nconst createNumber = (min, max) => ~~(Math.random() * (max - min + 1) + min);\n\nrouter.get('/', (req, res) => {\n    res.json({\n        status: 'overview',\n        methods: ['multiply', 'divide']\n    })\n})\n\nrouter.get('/multiply', (req, res) => {\n    let x = createNumber(0, 100), y = createNumber(0, 100);\n    res.json({ x, y, result: x * y });\n})\n\nrouter.get('/divide', (req, res) => {\n    let x = createNumber(0, 100), y = createNumber(0, 100);\n    res.json({ x, y, result: x / y });\n})\n\nexport default router;"},{"type":"code","crDate":1689163297965,"chDate":1689163308340,"text":"// server.js\nimport express from 'express';\nimport calcRoutes from './calcRoutes.js';\n\nconst server = express();\n\nserver.use('/', calcRoutes);\n\nserver.listen(8000, err => console.log(err || 'Server läuft'));\n"}]}