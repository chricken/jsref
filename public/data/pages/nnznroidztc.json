{"content":[{"type":"paragraph","crDate":1720768099324,"chDate":1720770817897,"text":"Ein Interface ist eine klare Definition für Klassen, welche Methoden vorhanden sein müssen, welche Parameter diese annehmen und welche Rückgabewerte sie zurückgegeben sollen. Diese Definition wird <i>Contract</i> genannt, Wenn die Programmiersprache keine festgelegten Parameter unterstützt, kann der Contract auch in Kommentaren oder in der Dokumentation niedergeschrieben sein.\nJavascript kennt keine Interfaces. Javascript bietet zu diesem Zweck die Klassen-Vererbung an.\nIn einer Klasse (dem \"Interface\") werden zunächst die erforderlichen Methoden und Parameter definiert und mit <i>Default</i>-Werten belegt.\nLaut der Definition von Interfaces müssen die Methoden und Attribute bei der Implementierung des Objektes überschrieben werden. Dies können wir im Falle von JS beiseite lassen, um den Code kompakter zu gestalten.\nDank eines anderen Patterns, den <i><a href=\"/?id=9svg3sp3hxw\">Named Arguments</a></i>, können in Javascript auch die erwarteten Parameter klar definiert werden."},{"type":"code","crDate":1720770099418,"chDate":1720771091103,"text":"class CarInterface {\n // Default-Attribute werden als Felder angelegt\n marke = '';\n modell = '';\n leistungKW = 0;\n inspektionen = [];\n get leistungPS() {\n  return ~~(this.leistungKW / .73 * 10) / 10;\n }\n addInspektion() {\n  this.inspektionen.push(payload);\n }\n}\n\nclass Car extends CarInterface {\n constructor({ marke = '', modell = '', leistungKW = 0 } = {}) {\n  super();\n  Object.assign(this, { marke, modell, leistungKW });\n  console.log(this);\n }\n addInspektion(payload) {\n  let isIncluded = this.inspektionen.some(val => {\n   return val.year == payload.year;\n  })\n  if (isIncluded) {\n   console.log(`Die Inspektion für ${payload.year} ist bereits eingetragen`);\n  } else {\n   this.inspektionen.push(payload);\n  }\n }\n}\n\nconst myCar = new Car({ marke: 'VW', modell: 'id3', leistungKW: 120 });\n\nconsole.log(myCar);\nconsole.log(myCar.leistungPS);"}]}