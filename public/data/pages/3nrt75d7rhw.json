{"content":[{"type":"paragraph","crDate":1770797644522,"chDate":1770797838267,"text":"Typescript wird von vielen Webentwicklern als überdimensioniert, irreführend und vor allem zu kompliziert wahrgenommen.\nDaher ist es vielleicht lohnenswert, sich Alternativen anzuschauen, um die gleiche Problematik mit weniger Aufwand zu lösen."},{"type":"subheader","crDate":1770799410780,"chDate":1770799414884,"text":"Javascript"},{"type":"paragraph","crDate":1770799417808,"chDate":1770800949800,"text":"Richtig gelesen, Javascript als Alternative zu Typescript.\nDer Zweck von Typescript ist vor allem die Typsicherheit. Das geht mit der Behauptung einher, Javascript böte keine solche Typsicherheit.\nMit ein bisschen Engagement lässt sich aber auch Javascript typsicher(er) programmieren.\n \n<b>Strikte Gleichheitsprüfung</b>\nDas wird oft unterschätzt. Javascripts <i>==</i> macht <i>implizite Typumwandlungen</i>, die zu unangenehmen Überraschungen führen können. Immer <i>===</i> und <i>!==</i> verwenden, um Typen und Werte explizit zu vergleichen.\n \n<b>Default-Parameter</b>\nNutze Default-Werte, um undefined-Probleme zu vermeiden.\n \n<b>Named Parameters (<a href=\"/?id=9svg3sp3hxw\">Link</a>)</b>\nNamed Arguments definieren die erwarteten Parameter einer Funktion und erlauben darüber hinaus keine weiteren Parameter.\n \n<b>Type Guards</b>\nUnsichere Typen (z.B. aus APIs), können explizit mit typeof, Array.isArray() oder benutzerdefinierten Checks geprüft werden.\n \n<b>Immutable Data Patterns</b>\nVermeide unerwartete Seiteneffekte, indem du Daten unveränderlich hältst. Nutze z.B. Object.freeze() für Konfigurationen oder const für Variablen\n \n<b>Schemavalidierung mit Plain Objects (<a href=\"/?id=fhc662r8eu0\">link</a>)</b>\nDefiniere \"Schemata\" als Objekte und prüfe Eingaben dagegen. Das ist quasi ein Mini-Typesystem\n \n<b>Factory Functions (<a href=\"/?id=lmm1mk69keo\">Link</a>)</b>\nVerwende Factory Functions, um Objekte mit garantierten Eigenschaften zu erzeugen. Das vermeidet this-Probleme und macht den Code vorhersehbarer. Dank des Scope in Javascript bieten Factories auch echte private Attribute.\n \n<b>Enums als gefrorene Objekte</b>\nSimuliere Enums mit Object.freeze(), um sicherzustellen, dass nur gültige Werte verwendet werden.\n \n<b>Optional Chaining und Nullish Coalescing (<a href=\"/?id=c167zhpbrw8\">Link</a>)</b>\nVermeide <i>Cannot read property of undefined</i>-Fehler mit modernem JavaScript.\n \n<b>Pure Functions und Input/Output-Kontrakte</b>\nSchreibe Funktionen, die:\n<ul>\n<li>Keine Seiteneffekte haben (keine externen Variablen ändern).</li>\n<li>Immer das gleiche Ergebnis für die gleichen Inputs liefern.</li>\n<li>Explizite Input/Output-Typen in der Dokumentation oder im Code klar machen</li>\n</ul>\n \n<b>Tests als Typsicherheitsnetz</b>\nUnit Tests (z.B. mit Jest oder Vitest) können Typfehler auffangen, indem sie <i>Edge Cases</i> prüfen.\n \n<b>Linter-Regeln für mehr Sicherheit</b>\nKonfiguriere ESLint mit Regeln wie:\n<ul>\n<li><b>no-implicit-coercion</b>: Verhindert implizite Typumwandlungen.</li>\n<li><b>no-unsafe-negation</b>: Verhindert !value, wenn value nicht boolean ist.</li>\n<li><b>valid-typeof</b>: Erzwingt korrekte typeof-Prüfungen.</li>\n</ul>\n \n<b>Custom Error Classes für bessere Fehlermeldungen</b>\nErstelle spezifische Fehlerklassen, um Typfehler klar zu kommunizieren\n \n<b>Functional Programming Helfer</b>\nLibraries wie <i>Ramda</i> oder <i>Lodash/FP</i> bieten Funktionen, die Typen explizit behandeln "},{"type":"subheader","crDate":1770797840674,"chDate":1770797848070,"text":"JSDoc"},{"type":"paragraph","crDate":1770797856432,"chDate":1770797993927,"text":"JSDoc ist eine einfache, aber mächtige Alternative:\nJavascript wird weiterhin wie gewohnt programmiert. Typinformationen werden als Kommentare hinzugefügt. \nViele moderne IDEs (auch WebStorm) unterstützen JSDoc und bieten damit fast die gleichen Vorteile wie TypeScript – <i>Autovervollständigung</i>, <i>Typprüfung</i>, <i>bessere Dokumentation</i> – ohne extra Transpilierungsschritt. \nBesonders praktisch, um bestehende Javascript-Projekte nachzurüsten oder einfach Overhead zu sparen."},{"type":"code","crDate":1770797996788,"chDate":1770798046473,"text":"/**\n * Addiert zwei Zahlen und gibt das Ergebnis zurück.\n * @param {number} a - Erste Zahl\n * @param {number} b - Zweite Zahl\n * @returns {number} Summe der beiden Zahlen\n */\nconst add = (a, b) => {\n  return a + b;\n}"},{"type":"code","crDate":1770798075420,"chDate":1770798092689,"text":"/**\n * Erstellt eine Begrüßungsnachricht für einen Nutzer.\n * @param {Object} user - Nutzerobjekt\n * @param {string} user.name - Name des Nutzers\n * @param {number} user.age - Alter des Nutzers\n * @returns {string} Personalisierte Begrüßung\n */\nconst greetUser = user => {\n return `Hallo, ${user.name}! Du bist ${user.age} Jahre alt.`;\n}\n\n// Beispielaufruf:\ngreetUser({ name: \"Hopps\", age: 4 }); // OK\ngreetUser({ name: \"Hopps\" }); // Warnung: Fehlendes 'age'!\n"},{"type":"links","crDate":1770798138749,"chDate":1770798138749,"text":"","links":[{"title":"Referenz","url":"https://jsdoc.app/"},{"title":"Wiki","url":"https://en.wikipedia.org/wiki/JSDoc"},{"title":"Blog-Artikel","url":"https://blog.openreplay.com/jsdoc--a-solid-alternative-to-typescript/"}]},{"type":"subheader","crDate":1770798336002,"chDate":1770798373052,"text":"Flow"},{"type":"paragraph","crDate":1770798375078,"chDate":1770798553798,"text":"Flow ist ein statischer <i>Typenchecker</i> von Facebook, der ähnlich wie TypeScript funktioniert, aber oft als weniger streng und einfacher zu integrieren empfunden wird. \nFlow erlaubt z.B. \"gradual typing\", also schrittweises Einführen von Typen, und kommt mit weniger Konfigurationsaufwand. \nDer Hauptunterschied: Flow ist eher ein \"Checker\" als eine eigene Sprache, d.h. du schreibst weiterhin Javascript und fügst Typen hinzu, wo du sie brauchst"},{"type":"links","crDate":1770798638604,"chDate":1770798638604,"links":[{"title":"Offizielle Webseite","url":"https://flow.org/"}]},{"type":"subheader","crDate":1770798657560,"chDate":1770798679677,"text":"Dart"},{"type":"paragraph","crDate":1770798682468,"chDate":1770798777181,"text":"Dart ist eine eigenständige Sprache, die nach Javascript kompiliert und ein starkes, aber <i>pragmatisches Typsystem</i> hat. \nDart fühlt sich für Javascript-Entwickler oft natürlicher an als Typescript, weil es von Grund auf für Webentwicklung designed wurde. \nDer Vorteil: Dart hat viele moderne Features und eine gute Tooling-Unterstützung, aber weniger \"Javascript-spezifische\" Macken"},{"type":"links","crDate":1770798792147,"chDate":1770798792147,"links":[{"title":"Wiki","url":"https://en.wikipedia.org/wiki/Dart_(programming_language)"},{"title":"Offizielle Webseite","url":"https://dart.dev/"}]},{"type":"subheader","crDate":1770798971866,"chDate":1770798979556,"text":"Weitere Alternativen"},{"type":"paragraph","crDate":1770798968663,"chDate":1770799296482,"text":"Es gibt noch viele weitere Alternative wie z.B. Kotlin, Elm, Rescript, AssemblyScript, Nim und mehr.\nAlle gehen einen leicht unterschiedlichen Weg, um dem Benutzer etwas mehr Typsicherheit zu bieten."}]}