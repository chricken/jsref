{"content":[{"type":"paragraph","crDate":1688731672700,"chDate":1688732252736,"text":"Promises sind ein moderner Weg, um mit asynchronen Funktionen umzugehen. Mit Promises werden verschiedene Probleme von asynchronen Funktionen gelöst und neue Möglichkeiten eröffnet.\nEinige der Vorteile von Promises sind:\n<ul>\n<li><b>Bessere Handhabung asynchroner Operationen</b>: Promises ermöglichen es, asynchronen Code zu schreiben, der fast so aussieht und sich verhält wie synchroner Code. Mit Promises können Sie eine Sequenz von asynchronen Operationen so schreiben, dass sie in einer bestimmten Reihenfolge ausgeführt werden.</li>\n<li><b>Fehlerbehandlung: Promises bieten robuste Fehlerbehandlung</b>. Wenn ein Fehler in einem Promise auftritt, wird er zum nächsten .catch()-Handler in der Kette weitergeleitet, was eine ähnliche Semantik wie try/catch in synchronem Code ermöglicht.\n</li><li><b>Vermeidung von Callback-Hell</b>: Promises helfen, die \"Callback-Hell\" zu vermeiden, ein häufiges Problem bei tief geschachtelten Callback-Funktionen. Sie machen den Code sauberer und leichter zu verstehen.</li>\n<li><b>Chaining</b>: Promises unterstützen \"chaining\", das bedeutet, dass man mehrere asynchrone Operationen in einer Sequenz ausführen kann, wobei jede Operation auf das Ergebnis der vorhergehenden wartet.</li>\n<li><b>Gleichzeitige Ausführung</b>: Mit Promise.all() können mehrere asynchrone Operationen gleichzeitig ausgeführt und darauf gewartet werden, dass alle abgeschlossen sind. Das ist nützlich, wenn mehrere Operationen unabhängig voneinander sind und parallel ausgeführt werden können.\n</li>\n</ul>"},{"type":"subheader","crDate":1688732283302,"chDate":1688732289653,"text":"Aufbau"},{"type":"paragraph","crDate":1688732292917,"chDate":1688733963399,"text":"Da Promises relativ komplex sind, wird im Folgenden ein Beispiel schrittweise aufgebaut.\nIn dieser Anleitung soll zunächst nur die technische Funktionsweise erklärt werden. In der Praxis werden Promises meistens etwas anders angewendet, dazu unten mehr.\nEin Promise wird als Rückgabewert des <i>Promise-Constructors</i> erzeugt. "},{"type":"code","crDate":1688732885289,"chDate":1688732886694,"text":"const myPromise = new Promise();"},{"type":"paragraph","crDate":1688732891816,"chDate":1688732952564,"text":"Der Constructor bekommt eine Funktion übergeben, den sogenannten <i>Executor</i>."},{"type":"code","crDate":1688732938173,"chDate":1688732943844,"text":"const myPromise = new Promise(() => { });"},{"type":"paragraph","crDate":1688732946148,"chDate":1688733097072,"text":"Der Executor wiederum bekommt einen oder zwei Parameter übergeben. \nDies sind Funktionen, die als quasi-Callback-Funktionen dienen.\nDer erste Parameter ist dazu gedacht, nach erfolgreichem Ausführen der Funktion aufgerufen zu werden.\nDer zweite Parameter soll bei Misserfolg aufgerufen werden.\nDer Executor wird nach dem Anlegen des Promise sofort automatisch aufgerufen. "},{"type":"code","crDate":1688733023175,"chDate":1688733039381,"text":"const myPromise = new Promise((resolve, reject) => { });"},{"type":"paragraph","crDate":1688734275064,"chDate":1688734516691,"text":"Was jetzt noch fehlt, ist der Code in der Funktion.\nHier soll beispielhaft einfach eine zufällige Zahl erzeugt werden. Diese zufällige Zahl soll außerhalb des Promise weiterverwendet werden. \nDaher wird die resolve()-Funktion aufgerufen, das Ergebnis wird als Argument übergeben.\n<b>Achtung</b>: Die Resolve-Funktion kann nur einen Parameter übergeben."},{"type":"code","crDate":1688734289895,"chDate":1688735488989,"text":"const myPromise = new Promise((resolve, reject) => {\n let z = Math.floor(Math.random() * 100);\n resolve(z);\n});"},{"type":"paragraph","crDate":1688733417410,"chDate":1688734921166,"text":"Zu jedem Promise gehört eine <i>then()</i>-Methode, die nach dem Anlegen des Promise aufgerufen werden kann.\nDer then()-Methode wird eine Funktion übergeben, die im Promise mit der <i>resolve()</i>-Funktion verknüpft wird. Wird also die resolve()-Funktion aufgerufen, dann feuert das die Funktion in der then()-Methode."},{"type":"code","crDate":1688734187304,"chDate":1688735484302,"text":"const myPromise = new Promise((resolve, reject) => { \n let z = Math.floor(Math.random() * 100);\n resolve(z);\n});\n\nmyPromise.then(\n result => console.log(result)\n)"},{"type":"paragraph","crDate":1688734556651,"chDate":1688734728053,"text":"Falls der Promise einen Misserfolg hat (Datei nicht gefunden o.ä.), dann kann der zweite Parameter (die <i>reject()</i>-Funktion) aufgerufen werden.\nZu der reject()-Funktion gehört eine optionale <i>catch()</i>-Methode. Diese wird an die then()-Methode gekettet und bei Aufruf der reject()-Funktion wird die übergebene Funktion aufgerufen."},{"type":"code","crDate":1688734753117,"chDate":1688735571494,"text":"const myPromise = new Promise((resolve, reject) => {\n let z = Math.floor(Math.random() * 100);\n if (z < 50) resolve(z);\n else reject(z);\n});\n\nmyPromise.then(\n result => console.log('resolve', result)  // -> z.B. resolve, 35\n).catch(\n err => console.log('reject', err)         // -> z.B. reject, 61\n)"},{"type":"subheader","crDate":1688737693099,"chDate":1688737698863,"text":"Asynchronität"},{"type":"paragraph","crDate":1688737416564,"chDate":1688737599982,"text":"Durch den Aufbau des Promise spielt es keine Rolle, ob der Code im Promise synchron oder asynchron ist.\nSobald die <i>resolve()</i>- oder <i>reject()</i>-Methode aufgerufen wird, starten die verknüpften <i>then()</i>- bzw <i>catch()</i>-Methoden.\nIm Beispiel wird als einfachste asynchrone Funktion ein <i>setTimeout()</i> genommen."},{"type":"code","crDate":1688737419379,"chDate":1688737683577,"text":"const myPromise = new Promise((resolve, reject) => {\n let z = Math.floor(Math.random() * 100);\n\n setTimeout(() => {\n  if (z < 50) resolve(z);\n  else reject(z);\n }, 1000)\n});\n\nmyPromise.then(\n result => console.log('resolve', result)  // -> z.B. resolve, 35\n).catch(\n err => console.log('reject', err)         // -> z.B. reject, 61\n)"},{"type":"subheader","crDate":1688737706965,"chDate":1688737709821,"text":"Chaining"},{"type":"paragraph","crDate":1688735399395,"chDate":1688735779262,"text":"Um mehrere Verarbeitungsschritte voneinander abhängig zu machen, können auch mehrere then()-Methoden <i>verkettet</i> werden. Dann wird der Rückgabewert der vorigen then()-Methode als Parameter an die nächste then()-Methode übergeben. Dieser Rückgabewert kann durchaus ein Promise sein."},{"type":"code","crDate":1688735837459,"chDate":1688735869989,"text":"const myPromise = new Promise((resolve, reject) => {\n let z = Math.floor(Math.random() * 100);\n if (z < 50) resolve(z);\n else reject(z)\n});\n\nmyPromise.then(\n result => {\n  console.log('resolve', result);\n  return result *2;\n }\n).then(\n result => {\n  console.log('resolve', result);\n  return result *2;\n }\n).then(\n result => {\n  console.log('resolve', result);\n  return result *2;\n }\n).then(\n result => {\n  console.log('resolve', result);\n }\n).catch(\n err => console.log('reject', err)\n)"},{"type":"subheader","crDate":1688737718742,"chDate":1688737724580,"text":"Mehrere then()"},{"type":"paragraph","crDate":1688735943202,"chDate":1688736297888,"text":"Es können übrigens auch mehrere then()-Methoden mit einem Promise verknüpft werden. Bei Aufruf von resolve() werden dann alle then()-Methoden gleichzeitig gefeuert."},{"type":"code","crDate":1688736162314,"chDate":1688736186721,"text":"const myPromise = new Promise((resolve, reject) => {\n let z = Math.floor(Math.random() * 100);\n resolve(z);\n});\n\nmyPromise.then(\n result => console.log('resolve', result)\n)\n\ndocument.querySelector('selector').addEventListener('click', () => {\n myPromise.then(\n  result => console.log('Klick', result)\n )\n})"},{"type":"subheader","crDate":1688736937649,"chDate":1688736942395,"text":"In der Praxis"},{"type":"paragraph","crDate":1688736923200,"chDate":1688737379733,"text":"In der Praxis werden Promises eher so eingesetzt, das der Promise als Rückgabewert von einer Funktion erzeugt wird.\nSo kann der Promise beliebig oft neu angelegt werden."},{"type":"code","crDate":1688737080654,"chDate":1688737095451,"text":"const myPromise = () => {\n return new Promise((resolve, reject) => {\n  let z = Math.floor(Math.random() * 100);\n  resolve(z);\n });\n}\n\ndocument.querySelector('button').addEventListener('click', () => {\n myPromise().then(\n  result => console.log('Klick', result)\n )\n})"}]}