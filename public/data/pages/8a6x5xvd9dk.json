{"content":[{"type":"paragraph","crDate":1721114276174,"chDate":1721121293300,"text":"Ein Debouncer wird gern verwendet, um sicherzugehen, dass eine Funktion nicht zu schnell nacheinander aufgerufen werden kann.\nUrsprünglich wurde der Debouncer dafür entwickelt, um mit dem Problem umzugehen, dass alternde Tastaturen anfangen, bei einem Anschlag mehrfach auszulösen (<i>Bouncing</i>).\nDebouncer werden vor allem in Zusammenhang mit Eventlistenern verwendet. Statt dem Eventlistener eine <i>Funktion</i> als Handler zuzuweisen, wird eine Funktion aufgerufen und der <i>Rückgabewert als Handler</i> zugewiesen.\nDieser Rückgabewert ist eine Funktion, in der die eigentliche Callback-Funktion mit Zeitverzögerung aufgerufen wird. Sollte dieser <i>Handler</i> innerhalb der Zeitverzögerung ein weiteres Mal aufgerufen werden, so wird durch die <i>clearTimeout()</i>-Funktion das Aufrufen der Funktion verhindert und ein weiteres timeout gestartet.\nDamit bei einem späteren Aufruf der vorige Aufruf unterbrochen werden kann, muss die timerID in einer Variablen stehen. Diese muss im Scope existieren, auf den beide Funktionsaufrufe zugreifen können. Daher wurde die timerID in einer Funktion angelegt, die eine Funktion zurückgibt. Sie auch <i><a href=\"/?id=9fyanrgs83g\">Closures</a></i>."},{"type":"code","crDate":1721115994173,"chDate":1721116028541,"text":"const createNumber = (min, max) => ~~(Math.random() * (max - min + 1) + min);\n\nconst myFunction = (func, delay, ...props) => {\n let timerID;\n return evt => {\n  clearTimeout(timerID);\n  timerID = setTimeout(func, delay, ...props);\n }\n}\n\nconst callback = (a, b) => {\n console.log(a, b, a * b);\n}\n\nbtn.addEventListener(\n 'click',\n myFunction(\n  callback,\n  1000,\n  createNumber(1, 100),\n  createNumber(1, 100)\n )\n);"}]}