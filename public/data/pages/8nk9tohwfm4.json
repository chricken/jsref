{"content":[{"type":"paragraph","crDate":1707228461439,"chDate":1707304318602,"text":"Werte in einer beliebigen Programmiersprache werden im Arbeitsspeicher abgelegt und eine Variable dient als Referenz zu diesem Speicherpunkt.\nArrays, Objekte, Maps, Sets, Funktionen und andere Werte werden kopiert, in dem eine <i>neue Variable</i> angelegt wird, die auf exakt dieselbe Stelle im Arbeitsspeicher zeigt, wie die originale Variable. Dieser Prozess wird <i>Copy by Reference</i> genannt.\nDas bedeutet, dass eine Änderung des Wertes über eine Variable auch in den Kopien zu sehen ist. Weil alle Variablen Verknüpfungen zu demselben Wert sind.\nassac"},{"type":"code","crDate":1707308415332,"chDate":1707308463329,"text":"const arr1 = [1, 2, 3];\nlet arr2 = arr1;\narr1[0] = 100;\n\nconsole.log(arr1);  // ->  [100, 2, 3]\nconsole.log(arr2);  // ->  [100, 2, 3]"},{"type":"paragraph","crDate":1707308535455,"chDate":1707308921066,"text":"Falls statt einer Referenz eine echte Kopie gewünscht ist, bietet sich die <i>Spread</i>-Syntax an.\nDiese trennt das Array in eine unstrukturierte Liste von Werten auf. Der Rückgabewert wird dann mit einer [ ] zu einem Array umgewandelt."},{"type":"code","crDate":1707309076803,"chDate":1707309138890,"text":"const arr1 = [1, 2, 3];\nlet arr2 = [...arr1];\narr1[0] = 100;\n\nconsole.log(arr1);  // -> [ 100, 2, 3 ]\nconsole.log(arr2);  // -> [ 1, 2, 3 ]"},{"type":"subheader","crDate":1707228981897,"chDate":1707309251051,"text":"Call by Reference"},{"type":"paragraph","crDate":1707229010951,"chDate":1707230041426,"text":"Die Übergabe eines Arrays (oder eines Objektes, etc.) an eine Funktion (sog. <i>Call by Reference</i>) ist nichts anderes als eine <i>Kopie</i> des Wertes. D.h., der Wert wird als Referenz zum Original übergeben und jede Änderung des Wertes wird im Original verändert.\nAls Clou behält der Wert seinen Scope. Im Beispiel wird eine Funktion aus einer Funktion aufgerufen und eine weitere Funktion übergeben. Da die übergebene Funktion als Referenz übergeben wurde, behält sie den Scope und kann auf die Werte aus der aufrufenden Funktion zugreifen. Nicht aber auf die Inhalt der Funktion, an die sie übergeben wurde."},{"type":"code","crDate":1707229856575,"chDate":1707229922898,"text":"const fHost = () => {\n let multiplyer = 4;\n\n const callback = value => {\n  return value * multiplyer;\n }\n\n fReceiver(callback);\n}\n\nconst fReceiver = f => {\n let result = f(10);\n console.log(result);\n}\n\nfHost();"},{"type":"subheader","crDate":1707227734620,"chDate":1707227767190,"text":"Compare by Reference"},{"type":"paragraph","crDate":1707227772814,"chDate":1707304698558,"text":"Auch bei einem Vergleich zweier Werte werden die Referenzen verglichen. Daher können zwei Arrays als nicht-gleich angesehen werden, auch wenn sie den gleichen Inhalt haben."},{"type":"code","crDate":1707307731723,"chDate":1707307999657,"text":"let arr1 = [1, 2, 3];\nlet arr2 = [1, 2, 3];\nlet arr3 = arr1;\n\nif (arr1 == arr2) {  // -> Ungleich\n console.log('Gleich');\n} else {\n console.log('Ungleich');\n}\n\nif (arr1 == arr3) {  // -> Gleich\n console.log('Gleich');\n} else {\n console.log('Ungleich');\n}"}]}