{"content":[{"type":"subheader","crDate":1758201976817,"chDate":1758201980563,"text":"useMemo"},{"type":"paragraph","crDate":1722952920835,"chDate":1758201966413,"text":"In React wird der Code einer Komponenten bei jeder Aktualisierung neu ausgeführt. Funktionen, die im Code referenziert wurden, werden ebenfalls bei jeder Aktualisierung aufgerufen.\nDas kann dann zum Probleme werden, wenn die aufgerufenen Funktionen lange in der Ausführung brauchen oder viele Ressourcen benötigen.\nIn einem solchen Fall gibt es eine Möglichkeit, das Ergebnis der Funktion zwischenzuspeichern.\nDer <i>useMemo()</i>-Hook bekommt zwei Parameter:\n<ul><li>Die Funktion, die ausgeführt werden soll.</li>\n<li>Ein Array mit Abhängigkeiten</li></ul>\nDie Funktion wird initial einmal ausgeführt. Der Rückgabewert der Funktion wird in der angegebenen Variablen (quasi einem State) gespeichert.\nErst dann, wenn sich eine Variable aus der Liste der Abhängigkeiten ändert, wird die Funktion wieder ausgeführt, um ein neues Zwischenergebnis zu erhalten.\nDadurch wird erreicht, dass die Funktion nur dann ausgeführt wird, wenn sich das Ergebnis geändert haben könnte. Ansonsten wird einfach das vorherige Ergebnis zurückgegeben.\nAuf dem Weg wird erreicht, dass eine Funktion nur so oft wie nötig aufgerufen wird."},{"type":"code","crDate":1758197254870,"chDate":1758632449411,"text":"import {useState, useMemo} from 'react'\nimport './App.css'\n\nconst App = () => {\n\n const [observed, setObserved] = useState(1);\n const [unobserved, setUnobserved] = useState(1);\n \n const inkrementObs = () => setObserved(observed + 1);\n const inkrementUnobs = () => setUnobserved(unobserved + 1);\n \n const createRandom = useMemo(() => {\n  return ~~(Math.random()*1000)\n }, [observed])\n\n return (\n  &lt;>\n   &lt;p>\n    {createRandom}\n   &lt;/p>\n   &lt;button onClick={inkrementObs}>\n    {observed} (+1)\n   &lt;/button>\n   &lt;button onClick={inkrementUnobs}>\n    {unobserved} (+1)\n   &lt;/button>\n  &lt;/>\n )\n}\n\nexport default App\n"},{"type":"subheader","crDate":1758201969799,"chDate":1758201986850,"text":"useCallback"},{"type":"paragraph","crDate":1758201989607,"chDate":1758631655137,"text":"Bei einem Re-Render werden nicht nur die Variablen neu angelegt, sondern auch die Funktionen.\nDas häufige Neu-Anlegen der Funktion kann u.U. Abhängigkeiten brechen oder unnötige Re-Renders auslösen.\nDaher wurde der <i>useCallback</i>-Hook erfunden.\nDieser funktioniert sehr ähnlich zum useMemo-Hook und wird häufig mit diesem zusammen eingesetzt.. \nEine Funktion wird nur dann erneut angelegt, wenn sich eine der Abhängigkeiten ändert."},{"type":"paragraph","crDate":1758631479093,"chDate":1758631571695,"text":"<b>Wann sollte man useCallback verwenden?</b>\nBeim Überrgeben einer Funktion als Argument an ein Kind, das mit <i>React.memo</i> optimiert ist, sorgt useCallback() dafür, dass die Funktionsreferenz stabil bleibt, solange sich die Abhängigkeiten nicht ändern. Das verhindert unnötige Re-Renders des Kindes\nWenn eine Funktion als Abhängigkeit in einem anderen Hook (z.B. useEffect, useMemo oder einem weiteren useCallback) verwendet wird, kann die Verwendungvon useCallback verhindern, dass Effekte oder Berechnungen unnötig oft ausgeführt werden\n\n."},{"type":"paragraph","crDate":1758631572350,"chDate":1758631574202,"text":"<b>Wann sollte useCallback nicht verwendet werden</b>\nWenn die Funktion nicht an ein Kind mit useMemo übergeben wird oder sie nicht als Abhängigkeit in einem anderen Hook verwendet wird, bringt useCallback() meist keinen Vorteil.\nÜbermäßiger Einsatz von useCallback kann den Code unnötig komplex machen und sogar die Performance verschlechtern, da das Memoisieren selbst auch Ressourcen verbraucht"}]}