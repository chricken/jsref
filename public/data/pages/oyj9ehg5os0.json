{"content":[{"type":"paragraph","crDate":1764334368323,"chDate":1764336625908,"text":"Die Typisierung einer Funktion ist etwas aufwendiger als bei einer einfachen Variablen, da eine Funktion durch viele Elemente gesteuert wird.\nEigentlich müsste jeder Parameter sowie der Rückgabewert einzeln den Datentypen zugewiesen bekommen. \nDas wird aber schnell unübersichtlich.\nAußerdem geht damit die Möglichkeit verloren, <i>default</i>-Werte zu vergeben\n"},{"type":"code","crDate":1764335194415,"chDate":1764336697170,"text":"const calcVolume = (breite: number, hoehe: number, tiefe: number): number => {\n return breite * hoehe * tiefe;\n}\n\nlet result: number = calcVolume(2, 3, 4)\nconsole.log(result);"},{"type":"paragraph","crDate":1764336500311,"chDate":1764339568544,"text":"Daher bietet sich hier ein <i>Type Alias</i> an, um den Datentypen zusammenzufassen.\nDer Type Alias für eine Funktion unterscheidet sich von den anderen Aliases durch seine Komplexität.\nWir legen für jeden Parameter den Datentypen in der Klammer und hinter der Klammer den Datentypen des Rückgabewertes fest.\nNun können wir für jede Funktion mit dieser Datentyp-Konfiguration das Alias verwenden."},{"type":"code","crDate":1764339480269,"chDate":1764339653697,"text":"type aliasVolume = (breite: number, hoehe:number, tiefe:number) => number;\n\nconst calcVolume: aliasVolume = (breite: 1, hoehe: 1, tiefe: 1) => {\n return breite * hoehe * tiefe;\n}\n\nlet result: number = calcVolume(2, 3, 4)\nconsole.log(result);\n\n\n\n"}]}