{"content":[{"type":"header","crDate":1770304351297,"chDate":1770304358565,"text":"Kontrollierte Formulare"},{"type":"paragraph","crDate":1770367092388,"chDate":1770370398010,"text":"Kontrollierte Formulare bedeutet, dass die Inhalte der Formularfelder im <i>State der Komponente</i> gespeichert ist.. Jede Änderung wird sofort in den State geschrieben.\nDas hat den Vorteil, dass der State immer den korrekten Inhalt hat, was z.B. Validierung vereinfacht."},{"type":"paragraph","crDate":1770367287627,"chDate":1770370398010,"text":"Hier ein Beispiel, um ein einfaches Formularfeld kontrolliert zu halten, \nEin <i>State</i> enthält den <i>Inhalt</i> des Eingabefeldes. Im Eingabefeld wird dieser State als <i>value</i> verwendet.\nWas noch fehlt ist ein <i>onChange</i>-Eventlistener, der den State updatet."},{"type":"code","crDate":1770367614796,"chDate":1770370398010,"text":"import { useState } from 'react';\n\nconst ControlledInput = () => {\n const [value, setValue] = useState('');\n\n const handleChange = (event) => {\n  setValue(event.target.value); // State wird bei jeder Änderung aktualisiert\n };\n\n return (\n  &lt;input\n   type=\"text\"\n   value={value}\n   onChange={handleChange}\n  />\n );\n};"},{"type":"subheader","crDate":1770368278538,"chDate":1770368305435,"text":"Mehrere Felder"},{"type":"paragraph","crDate":1770368307775,"chDate":1770370398010,"text":"Für Formulare kann der State am besten als Objekt verwaltet werden.\nJedes Eingabefeld wird mit einem Attribut des Objekte befüllt. Und es hat einen Eventlistener, der für alle Eingabefelder dieselbe Handler-Funktion feuert. \nIm Handler wird aus dem <i>target</i> der <i>name</i> entnommen, um den Attributnamen im <i>State</i>-Objekt zu erhalten. In diesen wird dann der <i>value</i> geschrieben."},{"type":"code","crDate":1770368777159,"chDate":1770370398010,"text":"import { useState } from 'react';\n\nconst MultiFieldForm = () => {\n const [formData, setFormData] = useState({\n  username: '',\n  email: '',\n  password: ''\n });\n\n const handleChange = (event) => {\n  const { name, value } = event.target;\n  setFormData({\n   ...formData,          // Behält alle anderen Felder bei\n   [name]: value         // Aktualisiert nur das geänderte Feld\n  });\n };\n\n const handleSubmit = (event) => {\n  event.preventDefault();\n  console.log('Formulardaten:', formData);\n };\n\n return (\n  &lt;form onSubmit={handleSubmit}>\n   &lt;input\n    type=\"text\"\n    name=\"username\"\n    value={formData.username}\n    onChange={handleChange}\n    placeholder=\"Benutzername\"\n   />\n   \n   &lt;input\n    type=\"email\"\n    name=\"email\"\n    value={formData.email}\n    onChange={handleChange}\n    placeholder=\"E-Mail\"\n   />\n   \n   &lt;input\n    type=\"password\"\n    name=\"password\"\n    value={formData.password}\n    onChange={handleChange}\n    placeholder=\"Passwort\"\n   />\n   &lt;button type=\"submit\">Absenden&lt;/button>\n  &lt;/form>\n );\n};\n\nexport default MultiFieldForm;"},{"type":"header","crDate":1770304360438,"chDate":1770304367742,"text":"Unkontrollierte Formulare"},{"type":"paragraph","crDate":1770370087837,"chDate":1770370398010,"text":"Bei sehr großen Formularen kann der kontrollierte Ansatz etwas Performance kosten. In dem Fall kann ein unkntrolkiertes Formular besser funktionieren. Diese Idee setzt auf dem <i>useRef</i>-Hook auf und legt für jedes Eingabefeld eine Referenz an.\nBeim Absenden des Formularen können diese Referenzen dann ausgelesen werden."},{"type":"code","crDate":1770370403423,"chDate":1770386907364,"text":"import { useRef } from 'react';\n\nconst UncontrolledInput = () => {\n const inputRef = useRef();\n\n const handleSubmit = (event) => {\n  event.preventDefault();\n  console.log(`Eingegebener Wert: ${inputRef.current.value}`);\n };\n\n return (\n  &lt;form onSubmit={handleSubmit}>\n   &lt;input type=\"text\" ref={inputRef} defaultValue=\"Standardwert\" />\n   &lt;button type=\"submit\">Absenden&lt;/button>\n  &lt;/form>\n );\n};\nexport default UncontrolledInput"}]}