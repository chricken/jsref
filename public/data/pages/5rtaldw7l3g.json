{"content":[{"type":"paragraph","crDate":1716450842293,"chDate":1716455865081,"text":"Hinter einer <i>Responsibility Chain</i> versteht man die Idee, dass eine Aufgabe in mehrere Teile untergliedert werden kann. Diese Teilaufgaben werden in verschiedenen Funktionen erledigt und die zu verarbeitenden Daten werden von einer Funktion zur nächsten weitergegeben.\nIn einer solchen Responsibility Chain kann der Aufruf der jeweils nächsten Funktion gelenkt werden."},{"type":"paragraph","crDate":1716455868381,"chDate":1716456107433,"text":"Im Beispiel unten werden für die Verkettung Promises verwendet.\nWenn in einer der Funktion ein Fehler oder eine problematische Situation auftritt, wird die Verarbeitung durch <i>reject</i> beendet."},{"type":"code","crDate":1716455673253,"chDate":1716455830290,"text":"const loadData = path => {\n return fetch(path).then(\n  res => res.json()\n );\n}\n\nconst filterNumbers = data => {\n data = data.filter(val => typeof val == 'number')\n console.log('Daten wurden gefiltert', data.length);\n\n return new Promise((resolve, reject) => {\n  if (data.length) {\n   resolve({\n    status: 'success',\n    data\n   })\n  } else {\n   reject('Nach dem Filtern ist das Array leer.')\n  }\n })\n}\n\nconst sortNumbers = res => {\n let data = res.data.toSorted((a, b) => a - b);\n\n return new Promise(resolve => {\n  resolve({\n   status: 'success',\n   data\n  })\n })\n}\n\nconst printData = res => {\n return new Promise((resolve, reject) => {\n  if (document) {\n   res.data.forEach((val, index) => {\n    const el = document.createElement('p');\n    el.innerHTML = `${index}: ${val}`;\n    document.body.append(el);\n   })\n   resolve({\n    status: 'success',\n    data: res.data\n   })\n  } else {\n   reject('Kein Document zur Ausgabe')\n  }\n })\n}\n\nconst init = () => {\n loadData('/data/my_data.json').then(\n  filterNumbers\n ).then(\n  sortNumbers\n ).then(\n  printData\n ).catch(\n  console.warn\n )\n}\n\ninit();"}]}