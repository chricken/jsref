{"content":[{"type":"subheader","crDate":1770295600048,"chDate":1770295604705,"text":"Synthetische Events"},{"type":"paragraph","crDate":1770295374946,"chDate":1770296295880,"text":"Im normalen DOM wird ein <i>Event</i> (z. B. ein Klick) direkt an den DOM-Knoten gebunden, der das Event auslöst. \nReact hingegen <i>kapselt</i> Browser-Events in sogenannte <i>synthetische Events</i>. \nDas hat mehrere Gründe:\n\n<b>Performance-Optimierung</b>\nReact nutzt Event Bubbling. Statt für jedes Element einen eigenen Event-Listener zu registrieren, fängt React alle Events auf der obersten Ebene (meistens am document-Objekt) ab und leitet sie dann an die entsprechenden Komponenten weiter. Das reduziert die Anzahl der DOM-Listener und verbessert die Performance.\n\n<b>Konsistente API</b>\nSynthetische Events haben immer die gleiche Schnittstelle, unabhängig vom Browser. Das bedeutet, du musst dich nicht um Browser-spezifische Eigenheiten kümmern (z. B. event.stopPropagation() vs. event.cancelBubble).\n\n<b>Cross-Browser-Kompatibilität</b>\nReact normalisiert Events, sodass sie in allen Browsern gleich funktionieren. Zum Beispiel wird onChange in React sowohl für &lt;input>- als auch für &lt;select>-Elemente verwendet, obwohl Browser diese Events unterschiedlich handhaben.\n\n"},{"type":"subheader","crDate":1770295941915,"chDate":1770295945045,"text":"Umsetzung"},{"type":"paragraph","crDate":1693565029032,"chDate":1770301626456,"text":"Gegenüber VanillaJS haben wir in React keine Möglickeit, auf die Inhaltsstruktur der Komponenten zuzugreifen und können daher auch nicht per addEventListener() Eventlistener anhängen.\nStattdessen werden Eventlistener direkt in JSX mit der <i>on-Syntax</i> zugewiesen. Dem Event wird als Expression der Eventhandler übergeben.\nBitte beachte, dass die Eventlistener mit innerCaps geschrieben werden.\nAuch wenn es so aussieht, als würde der Handler im HTML-Tag stehen - was nicht so nicht gemacht werden sollte - ist dies nicht der Fall (siehe Inspektor)"},{"type":"code","crDate":1693568119093,"chDate":1693568179938,"text":"const App = () => {\n const myFunction = () => console.log('Callback-Funktion');\n const handleInput = evt => console.log(evt.target.value);\n return (\n  &lt;>\n   &lt;p>\n    &lt;input onChange={handleInput} />\n   &lt;/p>\n   &lt;p>\n    &lt;button onClick={myFunction}>\n     Klick here\n    &lt;/button>\n   &lt;/p>\n  &lt;/>\n )\n}"},{"type":"subheader","crDate":1770296732450,"chDate":1770296742476,"text":"Event-Objekt"},{"type":"paragraph","crDate":1770296744864,"chDate":1770297164054,"text":"Das Event-Objekt eines React Eventlistsners ist angelehnt an das Event-Objekt in VanillaJS.\nDie Objekte sind immer gleich aufgebaut und enthalten die folgenden Elemente:\n<ul>\n<li><b>event.preventDefault():</b> Verhindert das Standardverhalten (z. B. Formular-Submit oder Link-Navigation).</li>\n<li><b>event.stopPropagation():</b> Stoppt das Bubbling des Events (verhindert, dass Eltern-Elemente das Event erhalten).</li>\n<li><b>event.nativeEvent:</b> Gibt Zugriff auf das ursprüngliche Browser-Event (selten benötigt).</li>\n<li><b>event.target:</b> Das DOM-Element, das das Event ausgelöst hat.</li>\n<li><b>event.currentTarget:</b> Das DOM-Element, an dem der Event-Listener hängt (in React meist identisch mit target).</li>\n</ul>"},{"type":"subheader","crDate":1770296404005,"chDate":1770300016484,"text":"Event-Propagations-Modell"},{"type":"paragraph","crDate":1770296646445,"chDate":1770300761697,"text":"Ebenso wie VanillaJS unterstützt auch React die drei Phases eines Events.\n<ul>\n<li><b>Capture-Phase</b>: Das Event wandert von der Wurzel (document) zum Ziel-Element (z. B. ein <button>). Sie wird nur selten verwendet,m wenn die Eltern-Elemente den Event auslösen sollen, bevor das target dies tut. </li>\n<li><b>Target-Phase</b>: Das Event wird am Ziel-Element ausgelöst.</li>\n<li><b>Bubbling-Phase</b>: Das Event wandert vom Ziel-Element zurück zur Wurzel. Dies wird gern verwendet, um in Elementen mit vielen Kindern (z.B. Listen) nur an einer Stelle den Eventlistener einhöngen zu müssen und dann mit event.target das tatsächlich angeklickte Element zu finden.</li>\n</ul>"},{"type":"subheader","crDate":1770300415505,"chDate":1770300426528,"text":"Target + Bubbling kombinieren"},{"type":"paragraph","crDate":1770300437602,"chDate":1770300439833,"text":"Ein typisches Szenario, das beide Phasen nutzt:\nEin Dropdown-Menü, das sich bei Klick auf den Button öffnet, aber bei Klick außerhalb schließt."},{"type":"code","crDate":1770300448561,"chDate":1770300548105,"text":"const Dropdown = () => {\n const [isOpen, setIsOpen] = useState(false);\n\n // Target-Phase: Button-Klick öffnet das Menü\n const handleButtonClick = (event) => {\n  event.stopPropagation(); // Verhindert, dass der Klick auf das Div bubbelt\n  setIsOpen(!isOpen);\n };\n\n // Bubbling-Phase: Klick außerhalb schließt das Menü\n const handleOutsideClick = () => {\n  setIsOpen(false);\n };\n\n return (\n  <div onClick={handleOutsideClick}> {/* Bubbling: Schließt Menü bei Klick außerhalb */}\n   <button onClick={handleButtonClick}>Menü öffnen</button> {/* Target: Toggle Menü */}\n    {isOpen && (\n     <ul>\n      <li>Option 1</li>\n      <li>Option 2</li>\n     </ul>\n    )}\n   </div>\n  );\n};"},{"type":"subheader","crDate":1770301216566,"chDate":1770301224345,"text":"Event-Pooling"},{"type":"paragraph","crDate":1770301228457,"chDate":1770301427318,"text":"React <i>recycelt</i> synthetische Events aus Performance-Gründen (\"Event-Pooling\"). Das heißt, nach der Event-Verarbeitung werden die Event-Objekte zurückgesetzt und wiederverwendet.\nWenn du asynchron auf ein Event zugreifst (z. B. in einem setTimeout), ist event möglicherweise null, weil React es bereits recycelt hat.\n<b>Lösung</b>: Falls du das Event-Objekt später benötigst, rufe <i>event.persist()</i> auf, um das Recycling zu verhindern:"},{"type":"code","crDate":1770301430960,"chDate":1770301463629,"text":"const handleClick = (event) => {\n event.persist(); // Event wird nicht recycelt\n\n setTimeout(() => {\n  console.log(event.target); \n }, 1000);\n};\n"}]}