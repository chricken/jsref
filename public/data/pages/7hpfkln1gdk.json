{"content":[{"type":"paragraph","crDate":1770894215623,"chDate":1770894705802,"text":"Eine zentrale Frage ist immer, wie Nutzdaten geladen werden sollen. Wo werden sie abgelegt und wie werden sie bereitgestellt.\nDabei sollte in nextJS immer beachtet werden: \nWenn möglich, sollten die Daten statisch in die Webseite eingebunden werden. Das ermöglicht das Rendern in SSG, was in der Verwendung weit schneller ist. \nWenn das nicht genügt oder möglich ist, sollte das Laden ins Layout betrachtet werden. Damit können die Daten im Server bereit gestellt werden und die Seite als SSR ausgeliefert werden.\nNur wenn auch das nicht sinnvoll ist, sollten die Daten in die page.js geladen werden. Dadurch wird clientseitiges Rendern erzwungen, was als die am wenigsten performante Variante gesehen wird."},{"type":"subheader","crDate":1770892487390,"chDate":1770892494236,"text":"Statisches Einbinden"},{"type":"paragraph","crDate":1770896041153,"chDate":1770896558789,"text":"Daten, die sich nicht häufig verändern (Content, Texte, Blogartikel, etc) können z.B. in einer JSON-Datei gespeichert werden. \nDiese JSON-Datei wird per <i>import</i> in eine beliebige Page eingebunden. \nBeim Build-Prozess werden die Inhalte der JSON-Datei in die page eingebunden und die JSON steht nicht mehr zur Verfügung.\nWenn nötig, kann der Aufruf von <i>npm run build</i> in ein eigenes Script gelegt werden, in dem zunächst die JSON-Datei aktualisiert und erst dann die Webseite gebuildet wird. So ist man sich sicher, dass der Inhalt der Page immer so aktuell ist wie der Build-Prozess.\nIm Beispiel unten ist die Dateistruktur:\n├ interesting-stuff\n├─ page.js\n├─ contents.json\n├ layout.js\n└ page.js"},{"type":"code","crDate":1770896334260,"chDate":1770896445462,"text":"// JSON-Datei content.js\n{\n \"paragraphs\": [\n  {\n   \"id\": \"1\",\n   \"text\": \"Hier steht etwas interessantes.\"\n  }, {\n   \"id\": \"2\",\n   \"text\": \"Dies ist auch sehr spannend.\"\n  }, {\n   \"id\": \"3\",\n   \"text\": \"Dies ist atemberaubend.\"\n  }\n ]\n}"},{"type":"code","crDate":1770896565815,"chDate":1770901759607,"text":"// Die Seite in /interesting-stuff/page.js\nimport contents from './contents.json'\n\nconst AboutArcPage = () => {\n const createContents = () => {\n  return contents.paragraphs.map(\n   content => &lt;p key={content.id}>{content.text}&lt;/p>\n  )\n }\n return (\n  &lt;>\n   &lt;h1>Interesting Stuff&lt;/h1>\n   {createContents()}\n  &lt;/>\n )\n}\n\nexport default AboutArcPage;"},{"type":"subheader","crDate":1770892499152,"chDate":1770892516628,"text":"Laden in das Layout"},{"type":"paragraph","crDate":1770896706027,"chDate":1770901995156,"text":"Daten, die sich häufiger ändern (z.B. aktuelle Benutzerstatistiken, Webseitenzugriffe, etc) können zur Laufzeit per <i>Ajax</i> geladen werden. Dies geschieht am besten in der layout.js, damit die Daten gecacht werden können und nicht unnötig oft abgerufen werden müssen. Die sich ändernden Inhalt werden dann per SSR erzeugt.\nIm Beispiel wollen wir das Menü dynamisch aus einer Server-Antwort (der Einfachheit halber als JSON-Datei) generieren.\nUnten ist der Inhalt der <i>menu.json</i> zu sehen, die im <i>public</i>-Verzeichnis liegt.\nDie Funktion <i>fetchMenu()</i> wird aufgerufen und lädt dann die Daten vom Server. Das kann eine Express-Route samt Datenbank-Zugriff sein oder - wie hier - eine JSON-Datei.\nDiese liefert die Daten, um das Menü dynamisch aufzubauen."},{"type":"code","crDate":1770901379308,"chDate":1770901459024,"text":"// /public/menu.json\n{\n \"links\": [\n  {\n   \"name\":\"Home\",\n   \"href\": \"/\"\n  }, {\n   \"name\":\"About\",\n   \"href\": \"/about-arc\"\n  }, {\n   \"name\":\"Impressum\",\n   \"href\": \"/imprint\"\n  }\n ]\n}"},{"type":"code","crDate":1770901464503,"chDate":1770901753795,"text":"import \"./globals.css\";\nimport Link from \"next/dist/client/link\";\n\nconst fetchMenu = async () => {\n const res = await fetch('http://localhost:1234/menu.json');\n return await res.json();\n}\n\nconst RootLayout = async ({children}) => {\n const menuData = await fetchMenu();\n return (\n  &lt;html lang=\"en\">\n   &lt;body>\n    &lt;nav>\n     {menuData.links.map(\n      link => &lt;Link href={link.href} key={link.href}>{link.name}&lt;/Link>\n     )}\n    &lt;/nav>\n    &lt;div className={'contents'}>\n     {children}\n    &lt;/div>\n   &lt;/body>\n  &lt;/html>\n );\n}\n\nexport default RootLayout;"},{"type":"subheader","crDate":1770902232374,"chDate":1770902235545,"text":"Caching"},{"type":"paragraph","crDate":1770902238849,"chDate":1770902833715,"text":"Um den Ladevorgang zu optimieren, kann der Zwischenspeicher gesteuert werden.\nIn der Ajax-Abfrage kann mit verschiedenen Attributen das Caching gesteuert werden.\n<ul>\n<li><b>cache: 'force-cache'</b>: Daten werden beim Build geladen (SSG).</li>\n<li><b>next: { revalidate: 60 }</b>: Daten werden alle 60 Sekunden neu geladen (ISR).</li>\n<li><b>cache: 'no-store'</b>: Daten werden bei jedem Request neu geladen (SSR).</li>\n</ul>"},{"type":"code","crDate":1770902840227,"chDate":1770902900020,"text":"const fetchMenu = async () => {\n const res = await fetch('http://localhost:1234/menu.json', {\n  next: { revalidate: 60 },\n  // cache: 'force-cache'\n  // cache: 'no-store'\n });\n return await res.json();\n}"},{"type":"subheader","crDate":1770892505986,"chDate":1770892513333,"text":"Laden in die Page"},{"type":"paragraph","crDate":1770903292278,"chDate":1770905947426,"text":"Daten direkt im Client einzubinden ist dann sinnvoll, wenn die Daten sehr häufig aktualisiert werden (Spielstände, Nachrichten, etc) oder wenn sie aufgrund einer Benutzer-Interaktion geladen werden. \nIn dem Fall bietet sich die üblichen React-Hooks an. Da diese aber eigentlich der Funktionsweise von nextJS widersprechen (SSG/SSR), wird über die Angabe von <i>\"use client\"</i> das client-seitige Rendern (<i>CSR</i>) erzwungen. "},{"type":"code","crDate":1770904245584,"chDate":1770906044970,"text":"'use client';\n\nimport {useState, useEffect} from 'react';\n\nconst fetchData = async () => {\n return fetch('http://localhost:1234/users.json').then(\n  res => res.json()\n )\n}\n\nexport default () => {\n const [data, setData] = useState([]);\n\n useEffect(() => {\n  fetchData().then(\n   data => setData(data)\n  ).catch(\n   console.warn\n  );\n }, []);\n\n return (\n  &lt;div>\n   &lt;h1>Echtzeit-Daten&lt;/h1>\n    {\n     data.map(user => &lt;p key={user.id}>{user.name} ({user.posts.length} Posts)&lt;/p>)\n    }\n   &lt;p>Letzte Aktualisierung: {new Date().toLocaleTimeString()}&lt;/p>\n  &lt;/div>\n );\n}\n"}]}