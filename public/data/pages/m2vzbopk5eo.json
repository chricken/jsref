{"content":[{"type":"subheader","crDate":1726213169812,"chDate":1726213172020,"text":"Index"},{"type":"paragraph","crDate":1726213086187,"chDate":1730128311823,"text":"Um effizient nach einem Datensatz zu suchen, sollte die Datenbank einen Index nach dem gewünschten Attribut enthalten. Daher auch der Name IndexedDB.\nEin Index in einer IndexedDB ist eine Struktur, die den schnellen Zugriff auf Daten ermöglicht, indem sie Daten nach einem bestimmten Attribut organisiert, anstatt nach dem Primärschlüssel.\nDer Index wird im <i>upgradeneeded</i>-Eventhandler angelegt und steht dann zur Verfügung.\nIm Beispiel soll ein Index naxch dem Attribut <i>leistungKW</i> angelegt werden."},{"type":"code","crDate":1730129399049,"chDate":1730129755776,"text":"const handleUpgradeNeeded = evt => {\n const db = evt.target.result;\n let myObjectStore;\n \n if (!db.objectStoreNames.contains(objStoreName)) {\n  // Falls der Objectstore noch nicht existiert, \n  // diesen erzeugen und Verknüpfung zurückgeben\n  myObjectStore = db.createObjectStore(\n   objStoreName, {\n    keyPath: 'id',\n    autoIncrement: true\n  })\n } else {\n  // Falls der Objectstore existier, Verknüpfung erzeugen\n  myObjectStore = evt.target.transaction.objectStore(objStoreName);\n }\n\n // Index erzeugen\n if (!myObjectStore.indexNames.contains('leistungKWIndex')) {\n  myObjectStore.createIndex(\n   'leistungKWIndex', \n   'leistungKW', \n   { unique: false }\n  );\n  console.log('Index leistungKWIndex wurde erfolgreich erstellt.');\n }\n}\n\nconst init = () => {\n requestDB = window.indexedDB.open(dbName, 6);\n requestDB.addEventListener('upgradeneeded', handleUpgradeNeeded);\n}\n\n\ninit();\n"},{"type":"subheader","crDate":1730131024483,"chDate":1730131030755,"text":"Cursor benutzen"},{"type":"paragraph","crDate":1730129780759,"chDate":1730130656359,"text":"Im nächsten Schritt kann der Index dann verwendet werden, um einen Bereich aus den Daten zu wählen. \nDazu bieten sich die statischen Methoden des <i>IDBKeyRange</i> Constructors an. Dieser bietet v.a. zwei Methoden an:\n<ul>\n<li><p>upperBound</b>: Alle Datensätze, deren Inhalt <= dem Argument ist\n<li><p>lowerBound</b>: Alle Datensätze, deren Inhalt >= dem Argument ist\n</ul>\nDiese Methoden erzeugen eine sog. <i>Range</i>, die dem <i>Index</i> als <i>Parameter</i> für den <i>Cursor</i> übergeben wird.\nDer Cursor wiederum bietet eine Art Iteration durch alle Datensätze. \nDie Syntax ist etwas seltsam: Wir haben einen Eventhandler für den <i>Success</i>-Event.\nDieser wird mit einem Datensatz im <i>evt</i>-Objekt aufgerufen. Der Datensatz wird verarbeitet und wenn irgendwo die <i>continue()</i>-Methode aufgerufen wird, dann wird der Eventhandler mit dem nächsten Datensatz aufgerufen.\nAuf diesem Wege können alle Datensätze einmal verarbeitet und z.B. in ein Array geschrieben werden."},{"type":"code","crDate":1730130663026,"chDate":1730130949113,"text":"const findDocuments = evt => {\n let myObjectStore = evt.target.result\n  .transaction(objStoreName, 'readonly')\n  .objectStore(objStoreName)\n\n // Suche nach Datensätzen mit leistungKW < 100\n const range = IDBKeyRange.upperBound(100);\n const cursorRequest = myObjectStore.index('leistungKWIndex')\n  .openCursor(range);\n\n // Daten sammeln\n const result = [];\n\n cursorRequest.addEventListener('success', evt => {\n  const cursor = evt.target.result;\n  if (cursor) {\n   result.push( cursor.value);\n   cursor.continue();\n  } else {\n   console.log(result);            \n  }\n });\n}\n\nconst init = () => {\n requestDB = window.indexedDB.open(dbName, 6);\n requestDB.addEventListener('success', findDocuments);\n}\n\ninit();"}]}