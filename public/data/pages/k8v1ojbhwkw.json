{"content":[{"type":"paragraph","crDate":1693911835096,"chDate":1726665382301,"text":"Die <i>async/await</i>-Syntax ist eine alternative Schreibweise für Promises.\nSie wird meist beworben als besser lesbar und besser organisierbar. Darüber hinaus bietet sie eine Möglichkeit, eigentlich asynchrone Funktionen als synchron zu behandeln."},{"type":"subheader","crDate":1726664167684,"chDate":1726664173481,"text":"Nachteile"},{"type":"paragraph","crDate":1726664175917,"chDate":1726664415142,"text":"Bei den Vorteilen dieser Syntax dürfen auch die Nachteile nicht aus den Augen verloren werden.\n<ul><li>eine async-Funktion ist nicht zu Fehlerbehandlung in der Lage und im Falle eines möglichen Fehlers muss die umständlichere <i>try-catch</i>-Syntax bemüht werden.</li>\n<li>Das await-Schlüsselwort kann nur in einer async-Funktion verwendet werden. Das schränkt die Flexibilität ein</li>\n<li>Da der Code eine Pause macht, bis das Ergebnis vorliegt, statt folgenden Code abzuarbeiten, kann die async-await-Syntax langsamer werden als sein Promise-Pendant.</li>\n</ul>"},{"type":"subheader","crDate":1726661937890,"chDate":1726661941662,"text":"async"},{"type":"paragraph","crDate":1726661949496,"chDate":1726662731829,"text":"Um die async/await-Syntax zu verwenden muss eine Funktion als asynchrone Funktion markiert werden. Das erfolgt dadurch, dass vor die Funktio das Schlüsselwort <i>async</i> geschrieben wird. \nDadurch werden Rückgabewerte der Funktion in einem Promise gewrapped. Dieser Promise ist immer erfüllt.\nAußerdem kann nur so in der Funktion der await-Befehl verwendet werden.\n"},{"type":"code","crDate":1726662204853,"chDate":1726662232213,"text":"// Ohne async\nconst createNumber = (min, max) => ~~(Math.random() * (max - min + 1) + min);\nlet num = createNumber(0,100);\nconsole.log(num);  // -> z.B. 91"},{"type":"code","crDate":1726662245791,"chDate":1726662286918,"text":"// Mit async\nconst createNumber = async (min, max) => ~~(Math.random() * (max - min + 1) + min);\nlet num = createNumber(0,100);\nconsole.log(num);  // -> Promise { &lt;state>: \"fulfilled\", &lt;value>: 79 }"},{"type":"subheader","crDate":1726662424646,"chDate":1726662429594,"text":"await"},{"type":"paragraph","crDate":1726662431442,"chDate":1726663343583,"text":"Das <i>await</i>-Schlüsselwort pausiert die Ausführung des Codes solange, bis der Promise erfüllt oder abgelehnt ist. \nWurde der Promise erfüllt, so gibt await den ausgelieferten Wert zurück.\nEin Nachteil der await-Syntax ist, dass sie nur in einer Funktion verwendet werden kann, die selbst als <i>async</i>-Funktion ausgeführt wird."},{"type":"code","crDate":1726662757590,"chDate":1726662769048,"text":"const createNumber = async (min, max) => ~~(Math.random() * (max - min + 1) + min);\n\nconst init = async () => {\n let num = await createNumber(0, 100);\n console.log(num);\n}\n\ninit();"},{"type":"paragraph","crDate":1726663356240,"chDate":1726663509599,"text":"Das funktioniert auch mit einer Funktion, die einen normalen Promise zurückliefert, z.B. fetch().\nIm Falle von <i>fetch</i> muss übrigens auch das Ergebnis mit await behandelt werden, weil die <i>json()</i>-Funktion ebenfalls einen Promise zurückliefert."},{"type":"code","crDate":1726663396069,"chDate":1726663418583,"text":"const init = async () => {\n let data = await fetch('https://dummyjson.com/products/1');\n data = await data.json();\n console.log(data);\n}\ninit();"},{"type":"subheader","crDate":1726664127549,"chDate":1726664132694,"text":"Fehlerbehandlung"},{"type":"paragraph","crDate":1726663984007,"chDate":1726664064960,"text":"Unhandlich wird die async-await-Syntax, wenn es darum geht, Fehler zu behandeln.\nDies ist in der synchronen Schreibweise nämlich nicht möglich, und so muss auf die unhandliche try-catch-Syntax zurückgegriffen werden."},{"type":"code","crDate":1726664067277,"chDate":1726664086118,"text":"const init = async () => {\n try {\n  let data = await fetch('diesgibtsnicht');\n  data = await data.json();\n  console.log(data);                \n } catch (err) {\n  console.warn('hoppala');\n }\n}\n\ninit();"},{"type":"subheader","crDate":1726664437193,"chDate":1726664445153,"text":"Synchronizität"},{"type":"paragraph","crDate":1726664447812,"chDate":1726665100646,"text":"Es gibt Situationen, in denen ein Promise als <i>synchrone Funktion</i> behandelt werden muss, um zum Ergebnis zu kommen.\nIn solchen Fällen ist die async-await-Syntax dem klassischen Promise deutlich überlegen.\nEin Beispiel wäre, nachfolgender Code tatsächlich verzögert ausgeführt werden soll."},{"type":"code","crDate":1726665124270,"chDate":1726665221116,"text":"const delay = time => {\n return new Promise(resolve => {\n  setTimeout(() => {\n   resolve();\n  }, time);\n })\n}\n\nconst init = async () => {\n await delay(1000);\n console.log(1);\n\n await delay(1000);\n console.log(2);\n\n await delay(1000);\n console.log(3);\n\n await delay(1000);\n console.log(4);\n}\n\ninit();"},{"type":"subheader","crDate":1726665839152,"chDate":1726665846571,"text":"Root Level Await"},{"type":"paragraph","crDate":1726665894647,"chDate":1726666048886,"text":"Seit ECMAScript2022 kann das await-Schlüsselwort auch auf dem Root-Level verwendet werden.\nBedingung ist, dass das Script in einem Modul geladen wird."},{"type":"code","crDate":1726666099744,"chDate":1726666103615,"text":"'use strict';\n\nlet res = await fetch('https://dummyjson.com/products/1');\nres = await res.json();\n\nconsole.log(res);\n\nconsole.log('Erledigt!');"}]}