{"content":[{"type":"paragraph","crDate":1770801123476,"chDate":1770801517661,"text":"Javascript wird gelegentlich als etwas wild empfunden, da die Datentypen gewechselt und automatisch angepasst werden. Schemavalidierung kann dieses Verhalten einschränken.\nEs wird ein Schema-Objekt definiert, das beschreibt, wie die Daten aussehen sollen. Dann prüft eine eine kleine Funktion die echten Daten gegen dieses Schema prüft. \nEiner der größte Vorteile ggü. Typescript ist, dass diese Technik auch zur Laufzeit funktioniert.\nKleiner Tipp: Es ist zwar etwas Schreibarbeit, aber davon kann </i>AI</i> einen Großteil übernehmen."},{"type":"subheader","crDate":1770801434622,"chDate":1770801436334,"text":"Beispiel: Nutzerdaten validieren"},{"type":"paragraph","crDate":1770801444831,"chDate":1770801477342,"text":"Angenommen, du hast ein Objekt, das einen Nutzer beschreibt.\nIm folgenden Beispiel wird das Objekt geprüft, ob es den Vorgaben entspricht."},{"type":"code","crDate":1770801525819,"chDate":1770801584302,"text":"const userSchema = {\n  name: \"string\",      // Muss ein String sein\n  age: \"number\",       // Muss eine Zahl sein\n  isSleepy: \"boolean\", // Muss true/false sein\n  friends: \"array\"     // Muss ein Array sein\n};\n\nconst validateUser = (user) => {\n return Object.keys(userSchema).every(key => {\n  const expectedType = userSchema[key];\n  const actualValue = user[key];\n\n  // Typprüfung\n  if (expectedType === \"string\" && typeof actualValue !== \"string\") {\n   return false;\n  }\n  if (expectedType === \"number\" && typeof actualValue !== \"number\") {\n   return false;\n  }\n  if (expectedType === \"boolean\" && typeof actualValue !== \"boolean\") {\n   return false;\n  }\n  if (expectedType === \"array\" && !Array.isArray(actualValue)) {\n   return false;\n  }\n  return true; // Alles okay\n });\n}\n\n// Test\nconst hopps = {\n  name: \"Hopps\",\n  age: 4,\n  isSleepy: true,\n  friends: [\"Möhre\", \"Löwenzahn\"]\n};\n\nconsole.log(validateUser(hopps)); // true\nconsole.log(validateUser({ name: 123 })); // false (name ist keine Zahl!)\n"},{"type":"subheader","crDate":1770801642637,"chDate":1770801644653,"text":"Fehlermeldungen"},{"type":"paragraph","crDate":1770801646933,"chDate":1770801668549,"text":"Statt nur true/false zurückzugeben, kannst du detaillierte Fehler sammeln.\nDas ist beim Debuggen besonders nützlich."},{"type":"code","crDate":1770801671307,"chDate":1770801750412,"text":"const validateWithErrors = (data, schema, path = \"\") => {\n const errors = [];\n\n for (const [key, expectedType] of Object.entries(schema)) {\n  const currentPath = path ? `${path}.${key}` : key;\n  const value = data[key];\n\n  if (expectedType === \"string\" && typeof value !== \"string\") {\n   errors.push(`${currentPath} muss ein String sein (ist ${typeof value})`);\n  }\n  else if (expectedType === \"number\" && typeof value !== \"number\") {\n   errors.push(`${currentPath} muss eine Zahl sein (ist ${typeof value})`);\n  }\n  else if (expectedType.type === \"array\") {\n   if (!Array.isArray(value)) {\n    errors.push(`${currentPath} muss ein Array sein`);\n   } else if (expectedType.items && !value.every(item => typeof item === expectedType.items)) {\n    errors.push(`${currentPath} enthält ungültige Elemente`);\n   }\n  }\n  // ... weitere Typen\n }\n\n  return errors.length ? errors : null;\n}\n\n// Test\nconst invalidRabbit = { name: 123, age: \"vier\" };\nconst errors = validateWithErrors(invalidRabbit, rabbitSchema);\nconsole.log(errors);\n// [\"name muss ein String sein (ist number)\", \"age muss eine Zahl sein (ist string)\"]\n"},{"type":"subheader","crDate":1770801809617,"chDate":1770801815815,"text":"Itegration in Klassen"},{"type":"paragraph","crDate":1770801820080,"chDate":1770801852339,"text":"Diese Funktionen lassen sich dann z.B. ganz einfach in Klassen einbauen."},{"type":"code","crDate":1770801854325,"chDate":1770801933838,"text":"class Rabbit {\n constructor(data) {\n  const errors = validateWithErrors(data, rabbitSchema);\n  if (errors) {\n   throw new Error(`Ungültiger Hase: ${errors.join(\", \")}`);\n  }\n  Object.assign(this, data);\n }\n}\n\ntry {\n const hopps = new Rabbit({ \n  name: \"Hopps\", \n  age: 4, \n  home: { \n   village: \"Hasendorf\", \n   burrowSize: 3 \n  }\n });\n console.log(\"Hase erstellt:\", hopps);\n} catch (err) {\n console.error(err.message);\n}\n"}]}