{"content":[{"type":"paragraph","crDate":1717676050003,"chDate":1717676732305,"text":"Animationen sind nichts anderes als schnell hintereinander gezeigte Bilder mit kleinen Unterschieden. Eine Reihe ähnlicher Änderungen wird in unserem Gehirn zu einer Bewegung zusammengeführt. Der einfachste Weg, eine solche Animation herzuführen ist der Aufruf über einen Intervall. "},{"type":"code","crDate":1717677031649,"chDate":1717677071030,"text":"const c = document.querySelector('#myCanvas');\nconst ctx = c.getContext('2d');\n\nlet box = { x: 100, y: 100, size: 60, speed: 5 };\n\nconst render = () => {\n ctx.clearRect(0, 0, c.width, c.height);\n ctx.fillRect(\n  box.x, box.y, box.size, box.size\n )\n\n // Objekt bewegen\n box.x += box.speed;\n box.y += box.speed / 3;\n\n // An der Kante zurücksetzen\n box.x = box.x % c.width;\n box.y = box.y % c.height;\n}\n\nsetInterval(render, 30);"},{"type":"subheader","crDate":1717677425887,"chDate":1717677431609,"text":"requestAnimationFrame()"},{"type":"paragraph","crDate":1717677151905,"chDate":1717677655119,"text":"Der Weg über setInterval() hat den Nachteil, dass die Animation nicht immer perfekt mit der Bildschirmausgabe synchronisiert ist. Das kann zu Mikro-Rucklern führen, was die Ausgabe auch auf starken Computern optisch verschlechtert.\nDaher ist der branchenübliche Weg zur Animation die <i>requestAnimationFrame()</i>-Funktion. Diese funktioniert so, dass sie dem Browser mittteilt, vor dem nächsten Neuzeichnen des Browsers eine Funktion aufzurufen. Die Funtion wird als Parameter übergeben.\nDie requestAnimationFrame()-Funktion ruft diese Funktion dann einmal auf, bevor der Bildschirm das nächste Mal aktualisiert wird.\nUm eine Animation zu erzeugen, muss die Funktion jedoch bei jedem Frame aufgerufen werden. Das wird erreicht, indem in der Callback-Funktion erneut requestAnimationFrame() ausgerufen wird."},{"type":"code","crDate":1717678443239,"chDate":1717678506179,"text":"const c = document.querySelector('#myCanvas');\nconst ctx = c.getContext('2d');\n\nlet box = { x: 100, y: 100, size: 60, speed: 5 };\n\nconst render = () => {\n ctx.clearRect(0, 0, c.width, c.height);\n ctx.fillRect(\n  box.x, box.y, box.size, box.size\n )\n \n // Objekt bewegen\n box.x += box.speed;\n box.y += box.speed / 3;\n\n // An der Kante zurücksetzen\n box.x = box.x % c.width;\n box.y = box.y % c.height;\n\n requestAnimationFrame(render);\n}\n\nrequestAnimationFrame(render);\n"},{"type":"paragraph","crDate":1717678527674,"chDate":1717679877389,"text":"Allerdings ist die requestAnimationFrame()-Funktion fest mit der Bildwiederholfrequenz des Bildschirms verknüpft. Da verschiedene Bildschirme mit unterschiedlichen Frequenzen laufen, laufen auch die Animationen mit unterschiedlichen Geschwindigkeiten.\nUm das zu vermeiden, kann die Zeit zwischen den Aufrufen gemessen werden und dann die Animation daran ausgerichtet werden.\nIm Beispiel werden die Millisekunden zwischen den Funktionsaufrufen gemessen. Die Bewegungsgeschwindigkeit wird in Pixel pro Sekunden angegeben. Und schließlich werden die zwischen den Frames zurückgelegten Pixel berechnet und verwendet. Auf diese Weise hat eine Animation immer die gleiche Geschwindigkeit, unabhängig von der Bildschirmfrequenz."},{"type":"code","crDate":1717679881375,"chDate":1717679938692,"text":"const c = document.querySelector('#myCanvas');\nconst ctx = c.getContext('2d');\n\nlet box = { x: 100, y: 100, size: 60, pxPerSec: 100 }\nlet lastTS = Date.now();\n\nconst render = () => {\n let deltaTime = Date.now() - lastTS;\n lastTS = Date.now();\n\n ctx.clearRect(0, 0, c.width, c.height);\n ctx.fillRect(\n  box.x, box.y, box.size, box.size\n )\n \n // Pixel berechnen\n let step = box.pxPerSec / 1000 * deltaTime;\n\n // Objekt bewegen\n box.x += step;\n box.y += step / 3;\n\n // An der Kante zurücksetzen\n box.x = box.x % c.width;\n box.y = box.y % c.height;\n\n requestAnimationFrame(render);\n}\n\nrequestAnimationFrame(render);\n"}]}