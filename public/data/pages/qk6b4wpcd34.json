{"content":[{"type":"subheader","crDate":1770040523584,"chDate":1770040527767,"text":"Store"},{"type":"paragraph","crDate":1770040815337,"chDate":1770040817025,"text":"Der zentrale Speicher einer Redux-Anwendung, der den gesamten Zustand (State) der App enthält. Alle Komponenten greifen auf diesen einzigen Store zu, um Daten zu lesen oder zu ändern."},{"type":"subheader","crDate":1770040566204,"chDate":1770040569386,"text":"State"},{"type":"paragraph","crDate":1770040875222,"chDate":1770040937510,"text":"Der aktuelle Datenbestand einer Anwendung zu einem bestimmten Zeitpunkt.\nIm State werden alle relevanten Informationen gespeichert (z. B. Nutzerdaten, Warenkorb-Inhalte). Er kann nicht direkt verändert werden, Änderungen müssen über <i>Actions</i> angestoßen werden."},{"type":"subheader","crDate":1770040546871,"chDate":1770040549467,"text":"Action"},{"type":"paragraph","crDate":1770041105634,"chDate":1770041155755,"text":"Ein Objekt, das eine Absicht zur Zustandsänderung beschreibt. \nActions werden mit <i>dispatch()</i> an den Store gesendet.\nEnthält:\n<ul>\n<li>Einen type (z. B. \"user/login\"),</li>\n<li>Optional eine payload mit zusätzlichen Daten (z. B. { name: \"Christian\" }).</i>\n</ul>"},{"type":"subheader","crDate":1770041160708,"chDate":1770041165171,"text":"dispatch()"},{"type":"paragraph","crDate":1770041422998,"chDate":1770041445635,"text":"Eine Funktion, die eine Action an den Redux-Store sendet, um eine Zustandsänderung auszulösen.\nWenn du z. B. ein Produkt in den Warenkorb legen willst, rufst du dispatch(addToCart(productId)) auf.\nDer Store leitet die Action dann an die passenden Reducer weiter, die den neuen State berechnen. Ohne dispatch() passiert im Store gar nichts – es ist quasi der \"Auslöser\" für alle Änderungen. In React-Komponenten bekommst du die Funktion über den <i>useDispatch()</i>-Hook."},{"type":"subheader","crDate":1770040510030,"chDate":1770040513567,"text":"Slice"},{"type":"paragraph","crDate":1770040978929,"chDate":1770041010885,"text":"Ein Abschnitt des Redux-Stores, der einen thematisch abgegrenzten Zustand (z. B. Nutzerdaten, Warenkorb) verwaltet. Ein Slice umfasst\n<ul>\n<li>Einen Anfangszustand (initialState),</li>\n<li>Reducer-Funktionen, die Änderungen am Zustand definieren,</li>\n<li>Automatisch generierte Actions zur Auslösung dieser Änderungen.</li>\n</ul>"},{"type":"subheader","crDate":1770040529868,"chDate":1770040544918,"text":"Reducer"},{"type":"paragraph","crDate":1770041048783,"chDate":1770041065635,"text":"Eine reine Funktion, die den aktuellen <i>State</i> und eine <i>Action</i> entgegennimmt und einen neuen State zurückgibt. Reducer bestimmen, wie der State auf eine bestimmte Action reagiert, ohne ihn direkt zu mutieren."},{"type":"subheader","crDate":1770040551634,"chDate":1770040683181,"text":"Toolkit"},{"type":"paragraph","crDate":1770041190154,"chDate":1770041230587,"text":"Eine Bibliothek, die Redux vereinfacht, indem sie:\n<ul>\n<li>Boilerplate-Code reduziert (z. B. durch createSlice),</li>\n<li>Standardisierte Lösungen für häufige Aufgaben bietet (z. B. Store-Konfiguration, Immutability-Handling),</li>\n<li>DevTools-Integration und Best Practices vordefiniert.</li>\n</ul>"},{"type":"subheader","crDate":1770041276491,"chDate":1770041280943,"text":"Immutable"},{"type":"paragraph","crDate":1770041282909,"chDate":1770041285195,"text":"Ein Prinzip, das besagt, dass der State nie direkt verändert werden darf. Stattdessen wird immer eine neue Kopie des States mit den gewünschten Änderungen erstellt. Dies ermöglicht vorhersehbare Zustandsübergänge und vereinfacht das Debugging."},{"type":"subheader","crDate":1770041327847,"chDate":1770041330595,"text":"Subscription"},{"type":"paragraph","crDate":1770041332104,"chDate":1770041379466,"text":"Ein Mechanismus, um Benachrichtigungen über Zustandsänderungen zu erhalten.\nIn Redux kann man sich mit <i>store.subscribe()</i> für Updates registrieren. In React wird dies implizit durch <i>useSelector</i> gehandhabt."}]}