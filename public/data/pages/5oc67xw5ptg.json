{"content":[{"type":"paragraph","crDate":1718368363874,"chDate":1718369233281,"text":"Das HTML-Template kann sehr schnell komplex und groß werden. Daher sollte es in einem eigenem Modul ausgelagert werden.\nDas Modul erzeugt den Container und alle seine Kind-Elemente. Dann exportiert es den Container.\n"},{"type":"code","crDate":1718369247020,"chDate":1718369331458,"text":"const template = document.createElement('div');\ntemplate.className = 'container';\n\nconst elHeader = document.createElement('h3');\nelHeader.innerHTML = 'A Title';\ntemplate.append(elHeader);\n\nconst elText = document.createElement('p');\nelText.innerHTML = 'A Content';\ntemplate.append(elText);\n\nexport default template;"},{"type":"paragraph","crDate":1718369336087,"chDate":1718369434488,"text":"Einer der Kernpunkte einer Webcomponent ist, dass das Styling vom Rest der Webseite unabhängig ist.\nDaher benötigt das Template im einfachsten Fall einen eigenen <i>&lt;style></i>-Tag, der den CSS-Code enthalten kann"},{"type":"code","crDate":1718369448373,"chDate":1718369480088,"text":"const template = document.createElement('div');\ntemplate.className = 'container';\n\nconst elHeader = document.createElement('h3');\nelHeader.innerHTML = 'A Title';\ntemplate.append(elHeader);\n\nconst elText = document.createElement('p');\nelText.innerHTML = 'A Content';\ntemplate.append(elText);\n\nconst elStyle = document.createElement('style');\ntemplate.append(elStyle);\nelStyle.innerHTML = `\n .container {\n  position: relative;\n  display: block;\n  background-color: hsl(30,80%,80%);\n  padding: 5px;\n  border: 1px solid rgba(0,0,0,.5);\n }\n`;\n\nexport default template;"},{"type":"subheader","crDate":1718369504870,"chDate":1718369508952,"text":"Viel CSS"},{"type":"paragraph","crDate":1718369495832,"chDate":1718370319956,"text":"Allerdings ist der CSS-Code nur selten so kurz. \nWeit häufiger wird der CSS-Code ebenso lang und komplex wie die Template-Datei. In dem Fall sollte der Code als CSS-Datei ausgelagert werden. \nDie Einbindung der CSS-Datei erfolgt mit einem <i>&lt;link></i>-Tag. Der bekommt mit dem <i>href</i>-Attribut den Pfad zur CSS-Datei mitgeteilt. Dieser Pfad ist aber ein Problem.\nDenn da die Webcomponent später in das HTML-Dokument eingebunden wird, ist dann auch der Pfad aus Sicht der HTML-Datei zu sehen. Ein absoluter Pfad ist keine Lösung, da dieser sehr unhandlich wäre.\nDie Lösung ist, den absoluten Dateipfad der aktuell geladenen JS-Datei zu lesen. Dazu kann mit dem <i>URL</i>-Constructor ein url-Objekt erzeugt werden, dessen <i>pathname</i>-Attribut den absoluten Pfad der Datei enthält.\nUnd der Pfad muss dann nur noch angepasst werden, um auf die CSS-Datei zugreifen zu können."},{"type":"code","crDate":1718370342558,"chDate":1718370429300,"text":"// template.js\n\nconst template = document.createElement('div');\ntemplate.className = 'container';\n\nconst elHeader = document.createElement('h3');\nelHeader.innerHTML = 'A Title';\ntemplate.append(elHeader);\n\nconst elText = document.createElement('p');\nelText.innerHTML = 'A Content';\ntemplate.append(elText);\n\n// STYLE\nconst elStyle = document.createElement('link');\nelStyle.rel = 'stylesheet';\n\n// Aktuelle Adresse der JSDatei auslesen\nlet localURL =  new URL(import.meta.url).pathname;\n\n// Dateiname der JS-Datei durch den Namen der CSS-Datei ersetzen\nlet indexLastSlash = localURL.lastIndexOf('/');\nlocalURL = localURL.substring(0, indexLastSlash + 1);\nlocalURL += 'styles.css';\n\n// CSS-Datei laden\nelStyle.href = localURL;\ntemplate.append(elStyle);\n\nexport default template;"},{"type":"code","crDate":1718369788305,"chDate":1718370446956,"text":"/* styles.css */\n\n.container { \n position: relative;\n display: block;\n background-color: hsl(30,80%,80%);\n padding: 5px;\n border: 1px solid rgba(0,0,0,.5);\n}\n\n/* viel mehr styles */"}]}