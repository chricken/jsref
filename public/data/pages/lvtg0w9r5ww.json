{"content":[{"type":"paragraph","crDate":1720437320786,"chDate":1720437779935,"text":"Javascript ist eine sog. Single Thread Sprache. Das bedeutet, dass Aufgaben nicht auf mehrere Prozesse verteilt werden können.\nDas wiederum bedeutet: Wenn JS sehr lange braucht, um eine Operation auszuführen, dann kann in der Zeit nichts anderes ausgeführt werden. Die Oberfläche \"friert ein\", die Webseite ist nicht benutzbar, bis die Operation ausgeführt ist.\nDas ist natürlich nicht gewünscht.\n<i>Webworker</i> sind eine Technologie, die es erlaubt, das Problem zu umgehen.\nWebworker nutzen das Verhalten moderner Browser, dass jeder Tab als eigener Prozess ausgeführt wird. Zeitaufwendige Operationen können dann in einen Worker ausgelagert werden. Wenn der Worker sehr lange braucht, um eine Operation auszuführen, dann beeinflusst dies die Oberfläche nicht. "},{"type":"subheader","crDate":1720439255652,"chDate":1720439258077,"text":"Worker"},{"type":"paragraph","crDate":1720437842360,"chDate":1720439280141,"text":"Der Worker selbst ist eine eigene JS-Datei.\nIm Worker kann mithilfe von <i>self</i> auf das globale Objekt zugegriffen werden (ähnlich \"window\" in normalem JS). Dieses Objekt enthält alle <i>Methoden</i> und <i>Eventlistener</i>, die den Worker selbst betreffen.\nDer Worker muss als eigenes, unabhängiges Script verstanden werden, das mit dem Haupt-Skript kommunizieren kann.\nIm Worker gibt es prinzipbedingt einige Einschränkungen:\n<ul>\n<li>Kein DOM</li>\n<li>Kein document-Objekt</i>\n<li>Keine Cookies</i>\n<li>Kein Webstorage</i>\n<li>Kein Zugriff auf den <i>globalen Scope</i> des Hauptskripts</li>\n<li>Keine Benutzer-Interaktion</i>\n</ul>\nWebworker sind so gedacht, dass sie im Hauptskript einmal (global) eingebunden werden und dann im Hintergrund laufen. \nDie Kommunikation zwischen der JS und dem Worker findet über Messages und Eventlistener statt. Vom JS kann eine Nachricht an den Worker gesendet werden und dort einen Eventlistener auslösen. Vom Worker ebenso eine Nachricht gesendet werden, die einen Eventlistener im JS auslöst."},{"type":"subheader","crDate":1720438457201,"chDate":1720439059101,"text":"message-Event"},{"type":"paragraph","crDate":1720439062116,"chDate":1720439243068,"text":"Im self-Objekt kann ein <i>message</i>-Eventlistener registriert werden.\nDieser reagiert darauf, dass von der Gegenseite eine Nachricht versendet wurde. An den Handler wird das <i>Message</i>-Objekt übergeben, welches u.a. ein data-Attribut hat. In diesem sind die übergebenen Daten (\"<i>Payload</i>\") enthalten. "},{"type":"code","crDate":1720439350112,"chDate":1720439390732,"text":"const handleMessage = msg => {\n console.log(msg.data);\n}\n\nself.addEventListener('message', handleMessage);"},{"type":"subheader","crDate":1720439043097,"chDate":1720439049476,"text":"Einbindung"},{"type":"paragraph","crDate":1720437794441,"chDate":1720439515323,"text":"Ein Worker wird über einen <i>Constructor</i> in Haupt-Skript eingebunden. Der Constructor bekommt als Parameter den Pfad zur Datei übergeben. Dabei ist zu beachten, dass der Pfad so geschrieben werden muss, als würde der Worker ins HTML einbettet werden. \nDie Einbindung erfolgt üblicherweise global, da der Ladeprozess relativ zeitraubend ist. "},{"type":"code","crDate":1720439544211,"chDate":1720439560436,"text":"const myWorker = new Worker('/assets/js/worker.js');"},{"type":"subheader","crDate":1720439564986,"chDate":1720439572130,"text":"postMessage()"},{"type":"paragraph","crDate":1720439578069,"chDate":1720440262900,"text":"Nachrichten werden mit der <i>postMessage()</i>-Methode an die Gegenseite übergeben. Diese konn vom Worker-Objekt an die Worker-Datei oder andersherum gegeben werden."},{"type":"code","crDate":1720440330882,"chDate":1720440463682,"text":"const myWorker = new Worker('/assets/js/worker.js');\n\nconst send = () => {\n worker.postMessage(42);\n}\n\nconst appendEventlisteners = () => {\n elements.btnSend.addEventListener('click', send);\n}"},{"type":"subheader","crDate":1722433299221,"chDate":1722433311136,"text":"Performance"},{"type":"paragraph","crDate":1722433295692,"chDate":1722434018229,"text":"Es gibt zwei grundlegende Wege, mit Webworkern umzugehen:\n<b>Worker einmal einbinden</b>\nund dann beliebig oft mit der <i>postMessage()</i>-Methode aufrufen.\nDas hat den Vorteil, dass die Worker-Datei nur einmal geladen werden muss. Es hat aber den Nachteil, dass eine Funktion, die im Worker lange läuft auch die folgenden Aufrufe des Workers verzögert.\n<b>Worker jedesmal einbinden</b>\nwenn er verwendet werden soll. Das hat den Vorteil, dass jede Worker-Instanz in einem eigenen Prozess läuft und sie sich nicht gegenseitig blockieren. Es hat aber den Nachteil, dass bei jedem Aufruf des Workers die Worker-Datei erneut geladen werden muss.\n"},{"type":"paragraph","crDate":1722434013598,"chDate":1722434019119,"text":"Diese Dinge sollten abgewägt werden, welcher Weg im Einzelfall die richtige Wahl ist."}]}