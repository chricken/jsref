{"content":[{"type":"subheader","crDate":1705072091994,"chDate":1705072236500,"text":"Nullish coalescing"},{"type":"paragraph","crDate":1705071881821,"chDate":1705072433206,"text":"Wenn ein Wert übergeben werden soll, kann es sinnvoll sein, sicherzugehen, ob der Wert einen Inhalt trägt. An der Stelle kann der <i>Nullish coalescing</i> Operator helfen. Dieser liefert den rechten Operanden, wenn der linke Operand null oder undefined ist. Sonst liefert er den linken Operanden zurück.\nEin ähnlicher Effekt lässt sich auch mit dem <i>logischen &&</i> erreichen. Allerdings würde beim && auch die Zahl 0 und ein leerer String den rechten Operanden zurückgeben."},{"type":"code","crDate":1705072514585,"chDate":1705072523391,"text":"let x = 122;\nlet y;\n\nlet wert1 = x ?? 42;\nlet wert2 = y ?? 42;\n\nconsole.log(wert1); // -> 122\nconsole.log(wert2); // -> 42"},{"type":"subheader","crDate":1705072553270,"chDate":1705072558989,"text":"Optional Chaining"},{"type":"paragraph","crDate":1705072561749,"chDate":1705072829970,"text":"Relativ häufig kommt es vor, dass ein abgefragtes Attribut in einem Objekt zu einem Fehler führt, weil eines seiner Eltern-Attribute nicht existiert. \nUm einen solchen Fall zu vermeiden, kann bei einem verschachtelten Attribut an die Eltern Attribute ein Fragezeichen \"<i>?</i>\" angehängt werden. Dieses überprüft, ob das Attribut existiert und fragt erst dann das nächste Kind in der Kette ab. Falls das ein Attribut in der Kette nicht existiert, liefert die Abfrage ein <i>undefined</i> anstelle eines Programm-Abbruchs."},{"type":"code","crDate":1705072938792,"chDate":1705073080017,"text":"const meinAuto = {\n marke: 'Hyundai',\n modell: 'i20',\n motor: {\n  leistungKW: 62,\n },\n bezeichnung(){\n  return `${this.marke} ${this.modell}`\n }\n}\n\nconsole.log( meinAuto?.motor?.leistungKW ); // -> 62\nconsole.log( meinAuto?.design?.farbe ); // -> undefined\nconsole.log( meinAuto?.bezeichnung?.() ); // Hyundai i20"}]}