{"content":[{"type":"subheader","crDate":1706106774285,"chDate":1706106776804,"text":"Strings"},{"type":"paragraph","crDate":1706106771941,"chDate":1706277936579,"text":"Wie jedes andere HTML-Element kann auch eine Web Component nur Strings als Attribute übergeben bekommen.\nDieses Attribut kann über HTML oder JS zugewiesen werden.\nDie Web Component muss vorbereitet werden:\n<ul>\n<li>Die zu beobachteten Attribute werden registriert.</li>\n<li>Der Getter sorgt dafür, dass bei einer Abfrage des Parameters die Daten ausgegeben werden.</li>\n<li>Der Setter sorgt dafür, dass bei einer Änderung der neue Wert eingetragen wird.</li>\n<li>Die Methode attributeChangedCallback() reagiert auf spezifische Änderungen von Parametern.</li>\n</ul>"},{"type":"code","crDate":1706278153506,"chDate":1706278208774,"text":"'use strict';\n\nconst template = document.createElement('div');\ntemplate.innerHTML = 'Dies ist mein eigenes Custom Element';\ntemplate.className = 'myComponent';\n\nclass myWB extends HTMLElement {\n constructor(){\n  super();\n  this.root = this.attachShadow();\n  this.root.append(template.cloneNode(true));\n }\n // Erwartete String-Attribute\n static get observedAttributes() {\n  return ['my-attribute']\n }\n    \n // Getter und Setter für String-Attribute\n get 'my-attribute'() {\n  return this.getAttribute('my-attribute')\n }\n set 'my-attribute'(val) {\n  this.setAttribute('my-attribute', val);\n }\n    \n // Eventlistener für veränderte Attribute\n attributeChangedCallback(attrName, oldVal, currentVal) {\n  if(attrName == 'my-attribute'){\n   // Tu etwas mit dem Value\n   console.log(currentVal);\n  }\n }\n}\n\ncustomElements.define('my-webcomp', myWB);"},{"type":"subheader","crDate":1706106780429,"chDate":1706106789588,"text":"Non-Strings"},{"type":"paragraph","crDate":1706278747774,"chDate":1706279819637,"text":"Eigentlich können Web Componenten keine Parameter annehmen, die keine Strings sind. Daher müssen wir in die Trickkiste greifen, um Funktionen oder Datensammlungen in die Web Componente zu übertragen. \nEs bietet sich eine Funktion an, die aufgerufen werden kann, denn einer Funktion können beliebige Datentypen übergeben werden."},{"type":"code","crDate":1706279824014,"chDate":1706281236827,"text":"// Anlegen der Web Component\n'use strict';\n\nconst template = document.createElement('div');\ntemplate.className = 'myComponent';\n\nclass myWB extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'open'\n  });\n  this.root.append(template.cloneNode(true));\n }\n\n setOptions(contents=[]){\n  this.root.innerHTML = '';\n  contents.forEach(val => {\n   const el = document.createElement('p');\n   el.innerHTML = val;\n   this.root.append(el);\n  })\n }   \n}\n\ncustomElements.define('my-webcomp', myWB);"},{"type":"code","crDate":1706281240434,"chDate":1706281310381,"text":"// Aufrufen, Parameterübergabe und Einbindung\n\nconst elContents = document.createElement('my-webcomp');\nelContents.setOptions([\n \"Web Components are reusable HTML elements.\",\n \"They provide a way to package reusable cod.\",\n \"Web Components allow developers to create custom elements.\",\n \"This promotes code reuse, modularity, and maintainability.\",\n \"Web Components are supported by all major web browsers.\",\n])\ndocument.body.append(elContents)"}]}