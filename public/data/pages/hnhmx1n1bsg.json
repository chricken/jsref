{"content":[{"type":"paragraph","crDate":1754561988140,"chDate":1755074202622,"text":"Bevor React Context eingeführt wurde, mussten Entwickler häufig mit dem sogenannten <i>Prop Drilling</i> umgehen – einer unbeliebten Technik, bei der Props durch mehrere Komponenten-Ebenen hindurch weitergereicht werden müssen, selbst wenn Zwischenkomponenten diese Daten gar nicht benötigen.\nEinzige Alternative war die Verwendung von Tools wie Redux, eine aufwendige und komplexe Lösung, die für die meisten Anwendungen unnötig kompliziert ist."},{"type":"paragraph","crDate":1722952839563,"chDate":1753788517081,"text":"Der Context erlaubt es, an übergeordneter Stelle Daten abzulegen und von Kind-Komponenten aus darauf lesend und schreibend zuzugreifen. Dadurch können Informationen ohne viel Aufwand bei der Parameterübergabe in der ganzen App verwendet werden.\nKern des Contexts ist die <i>createContext()</i>-Methode. Diese legt den Context an und stellt alle Methoden bereit, um mit dem Context arbeiten zu können.\nEs ist ein guter Weg, den Context in einer eigenen Datei anzulegen, um ihn importieren zu können, falls gewünscht."},{"type":"code","crDate":1723035098596,"chDate":1754563152605,"text":"// MyContext.js\nimport {createContext} from 'react';\n\nconst MyContext = createContext({\n car: {\n  marke: 'default',\n  modell: 'default'\n }\n});\n\nexport default MyContext;"},{"type":"paragraph","crDate":1723035121562,"chDate":1723035877395,"text":"MyContext ist ein Objekt, das ein Attribut namens <i>Provider</i> enthält. Dieser ist eine Komponente. \nDiese Provider-Komponente wird verwendet, um die Daten für eine andere Komponente zur Verfügung zu stellen.\nAn den Provider wird als <i>value</i>-Attribut die gewünschten Daten übergeben. Diese stehen dann in der/den aufgerufenen Komponente(n) zur Verfügung."},{"type":"code","crDate":1723035771795,"chDate":1771342341364,"text":"// App.js\nimport MyContext from './MyContext.jsx';\nimport MyComp from './MyComp.jsx';\nimport {useState} from \"react\";\n\nconst App = () => {\n // Definiere den Wert des Contexts\n const [car, setCar] = useState({\n  marke: 'Hyundai',\n  modell: 'i20'\n });\n\n return (\n  &lt;>\n   {/* Stelle den Context-Wert als Objekt bereit */}\n   &lt;MyContext.Provider value={{car, setCar}}>\n    &lt;MyComp />\n   &lt;/MyContext.Provider>\n  &lt;/>\n );\n};\n\nexport default App;"},{"type":"paragraph","crDate":1723035894402,"chDate":1754561650868,"text":"In jeder Komponente, die innerhalb der Provider-Komponenten verschachtelt wird, kann der Context importiert werden. \nDie <i>useContext()</i>-Funktion kann dann in der Komponenten auf die zuvor abgelegten Daten zurückgreifen.\nWeitere Komponenten, die in der Komponenten verschachtelt werden, haben automatisch ebenfalls Zugriff auf die useContent()-Funktion."},{"type":"code","crDate":1723035891799,"chDate":1771342335948,"text":"import {useContext} from 'react';\nimport MyContext from './MyContext.jsx';\nimport InnerComp from './InnerComp.jsx';\n\nconst MyComp = () => {\n // Verwende den Context-Hook, um den Wert des Contexts abzurufen\n const { car } = useContext(MyContext);\n\n return (\n  &lt;>\n   &lt;div>\n    &lt;p> Marke: {car.marke} &lt;/p>\n    &lt;p> Modell: {car.modell} &lt;/p>\n   &lt;/div>\n   &lt;div>\n    &lt;InnerComp />\n   &lt;/div>\n  &lt;/>\n );\n};\n\nexport default MyComp;"},{"type":"subheader","crDate":1771341068422,"chDate":1771342305259,"text":"Kompaktere Variante"},{"type":"paragraph","crDate":1771341078548,"chDate":1771342232082,"text":"Der Umgang mit dem Context kann auch etwas kompakter gestaltet werden.\nWährend wir im Beispiel oben die einzelnen Schritte in eigene Module aufgeteilt haben, lass uns die Elemente zu einem <i>customHook</i> zusammenfassen.\nIm folgenden Beispiel soll eine Liste der Planeten bereitgestellt werden.\nWir legen dazu eine Komponente an, die alle Elemente enthält, um die Daten bereitzustellen.\n<i>createContext()</i> erstellt den Container, der vom Provider gefüllt wird.\n<i>PlanetsProvider()</i> ist eine fertige Komponente, in der bereits der Context-Provider eingebunden ist und übergebene Children (<a href=\"/?id=9jrbyz89uzo\">Link</a>) verschachtelt.\n<i>usePlanets()</i> stellt die Daten aus dem Context in allen Children zur Verfügung."},{"type":"code","crDate":1771342235281,"chDate":1771342299393,"text":"import {createContext, useState, useContext} from 'react';\n\nconst PlanetsContext = createContext({\n planets: []\n})\n\nexport const PlanetsProvider = ({children}) => {\n const [planets] = useState([\n  {id: 1, name: 'Mercury'},\n  {id: 2, name: 'Venus'},\n  {id: 3, name: 'Earth'},\n  {id: 4, name: 'Mars'}\n ])\n\n return (\n  &lt;PlanetsContext.Provider value={planets}>\n   {children}\n  &lt;/PlanetsContext.Provider>\n )\n}\n\nexport const usePlanets = () => useContext(PlanetsContext)"},{"type":"paragraph","crDate":1771342379106,"chDate":1771342534470,"text":"In der App wird dann <i>Provider</i> eingebunden, der über einen <i>benannten Export</i> zur Verfügung gestellt wurde.\nIn die Provider-Komponente wird die <i>Planetslist-Komponente</i> verschachtelt, die ja im PlanetsProvder als <i>Children</i> eingehängt ist."},{"type":"code","crDate":1771342412525,"chDate":1771342690346,"text":"import {PlanetsProvider} from \"./PlanetsContext.jsx\";\nimport Planetslist from \"./Planetslist.jsx\";\n\nconst App = () => {\n return (\n  &lt;>\n   &lt;h1>App&lt;/h1>\n   &lt;PlanetsProvider>\n    &lt;Planetslist/>\n   &lt;/PlanetsProvider>\n  &lt;/>\n )\n}\n\nexport default App"},{"type":"paragraph","crDate":1771342584513,"chDate":1771342677535,"text":"Fehlt nur noch die Komponente zur Darstellung. Die Planetslist.jx.\nIn dieser wird die <i>usePlanets()</i>-Funktion verwendet, um Zugriff auf die Daten zu gewährleisten."},{"type":"code","crDate":1771342614193,"chDate":1771342687318,"text":"import {usePlanets} from \"./PlanetsContext.jsx\";\n\nconst Planetslist = () => {\n const planets = usePlanets()\n return (\n  &lt;ul>\n   {planets.map(planet => &lt;li key={planet.id}>{planet.name}&lt;/li>)}\n  &lt;/ul>\n )\n}\n\nexport default Planetslist;"},{"type":"subheader","crDate":1771340194235,"chDate":1771340205278,"text":"Daten ändern"},{"type":"paragraph","crDate":1771340207396,"chDate":1771340207396,"text":""},{"type":"subheader","crDate":1754563216091,"chDate":1754563531433,"text":"Wann Context verwenden"},{"type":"paragraph","crDate":1754563234971,"chDate":1754563514068,"text":"Neben dem Context-Hook gibt es noch andere, fortgeschrittene Möglichkeiten. \nDiese sind aber auch komplexer.\n<ul><li>Für \"globale\" App-Daten wie Benutzerinformationen, Themes, Sprachen</li>\n<li>Für Daten, die von vielen Komponenten benötigt werden</li>\n<li>Als Alternative zu Prop Drilling durch viele Ebenen</li>\n<li>In Kombination mit useReducer für komplexere State-Logik</li></ul>"},{"type":"subheader","crDate":1754563226910,"chDate":1754563232972,"text":"Wann besser nicht"},{"type":"paragraph","crDate":1754563416779,"chDate":1754563500091,"text":"<ul><li>Für stark lokalisierte Daten, die nur wenige benachbarte Komponenten teilen</li>\n<li>Wenn Performance kritisch ist (State Management Bibliotheken wie Redux bieten Optimierungen)</li>\n<li>Wenn Sie erwarten, dass sich die Daten sehr häufig ändern</li></ul>"}]}