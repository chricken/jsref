{"content":[{"type":"paragraph","crDate":1754561988140,"chDate":1755074202622,"text":"Bevor React Context eingeführt wurde, mussten Entwickler häufig mit dem sogenannten <i>Prop Drilling</i> umgehen – einer unbeliebten Technik, bei der Props durch mehrere Komponenten-Ebenen hindurch weitergereicht werden müssen, selbst wenn Zwischenkomponenten diese Daten gar nicht benötigen.\nEinzige Alternative war die Verwendung von Tools wie Redux, eine aufwendige und komplexe Lösung, die für die meisten Anwendungen unnötig kompliziert ist."},{"type":"paragraph","crDate":1722952839563,"chDate":1753788517081,"text":"Der Context erlaubt es, an übergeordneter Stelle Daten abzulegen und von Kind-Komponenten aus darauf lesend und schreibend zuzugreifen. Dadurch können Informationen ohne viel Aufwand bei der Parameterübergabe in der ganzen App verwendet werden.\nKern des Contexts ist die <i>createContext()</i>-Methode. Diese legt den Context an und stellt alle Methoden bereit, um mit dem Context arbeiten zu können.\nEs ist ein guter Weg, den Context in einer eigenen Datei anzulegen, um ihn importieren zu können, falls gewünscht."},{"type":"code","crDate":1723035098596,"chDate":1754563152605,"text":"// MyContext.js\nimport {createContext} from 'react';\n\nconst MyContext = createContext({\n car: {\n  marke: 'default',\n  modell: 'default'\n }\n});\n\nexport default MyContext;"},{"type":"paragraph","crDate":1723035121562,"chDate":1723035877395,"text":"MyContext ist ein Objekt, das ein Attribut namens <i>Provider</i> enthält. Dieser ist eine Komponente. \nDiese Provider-Komponente wird verwendet, um die Daten für eine andere Komponente zur Verfügung zu stellen.\nAn den Provider wird als <i>value</i>-Attribut die gewünschten Daten übergeben. Diese stehen dann in der/den aufgerufenen Komponente(n) zur Verfügung."},{"type":"code","crDate":1723035771795,"chDate":1754563147319,"text":"// App.js\nimport MyContext from './MyContext.jsx';\nimport MyComp from './MyComp.jsx';\nimport {useState} from \"react\";\n\nconst App = () => {\n // Definiere den Wert des Contexts\n const [car, setCar] = useState({\n  marke: 'Hyundai',\n  modell: 'i20',\n  leistungKW: 62,\n  farbe: 'braun',\n });\n\n return (\n  &lt;>\n   {/* Stelle den Context-Wert als Objekt bereit */}\n   &lt;MyContext.Provider value={{car, setCar}}>\n    &lt;MyComp />\n   &lt;/MyContext.Provider>\n  &lt;/>\n );\n};\n\nexport default App;"},{"type":"paragraph","crDate":1723035894402,"chDate":1754561650868,"text":"In jeder Komponente, die innerhalb der Provider-Komponenten verschachtelt wird, kann der Context importiert werden. \nDie <i>useContext()</i>-Funktion kann dann in der Komponenten auf die zuvor abgelegten Daten zurückgreifen.\nWeitere Komponenten, die in der Komponenten verschachtelt werden, haben automatisch ebenfalls Zugriff auf die useContent()-Funktion."},{"type":"code","crDate":1723035891799,"chDate":1754563117546,"text":"import {useContext} from 'react';\nimport MyContext from './MyContext.jsx';\nimport InnerComp from './InnerComp.jsx';\n\nconst MyComp = () => {\n // Verwende den Context-Hook, um den Wert des Contexts abzurufen\n const { car } = useContext(MyContext);\n\n return (\n  &lt;>\n   &lt;div>\n    &lt;p> Marke: {car.marke} &lt;/p>\n    &lt;p> Modell: {car.modell} &lt;/p>\n    &lt;p> Leistung: {car.leistungKW} KW&lt;/p>\n    &lt;p> Farbe: {car.farbe} &lt;/p>\n   &lt;/div>\n   &lt;div>\n    &lt;InnerComp />\n   &lt;/div>\n  &lt;/>\n );\n};\n\nexport default MyComp;"},{"type":"subheader","crDate":1754563216091,"chDate":1754563531433,"text":"Wann Context verwenden"},{"type":"paragraph","crDate":1754563234971,"chDate":1754563514068,"text":"Neben dem Context-Hook gibt es noch andere, fortgeschrittene Möglichkeiten. \nDiese sind aber auch komplexer.\n<ul><li>Für \"globale\" App-Daten wie Benutzerinformationen, Themes, Sprachen</li>\n<li>Für Daten, die von vielen Komponenten benötigt werden</li>\n<li>Als Alternative zu Prop Drilling durch viele Ebenen</li>\n<li>In Kombination mit useReducer für komplexere State-Logik</li></ul>"},{"type":"subheader","crDate":1754563226910,"chDate":1754563232972,"text":"Wann besser nicht"},{"type":"paragraph","crDate":1754563416779,"chDate":1754563500091,"text":"<ul><li>Für stark lokalisierte Daten, die nur wenige benachbarte Komponenten teilen</li>\n<li>Wenn Performance kritisch ist (State Management Bibliotheken wie Redux bieten Optimierungen)</li>\n<li>Wenn Sie erwarten, dass sich die Daten sehr häufig ändern</li></ul>"}]}