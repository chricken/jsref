{"content":[{"type":"paragraph","crDate":1754302930485,"chDate":1754311790042,"text":"<i>Decorators</i> sind Funktionen, die zusätzlich an Klassen-Methoden angehängt werden können. \nSie erlauben es, zusätzliche Funktionen bereitzustellen, ohne die Methode selbst erweitern zu müssen. Beliebt sind sie z.B. fürs Logging u.ä.\nEin Decorator wird als normale Funktion angelegt. Diese enthält drei Parameter:\n<ul>\n<li><b>target: </b>Das Element (meistens der Constructor/die Klasse), auf das der Decorator angewendet wurde.</li>\n<li><b>propertyKey: </b>Der Name der Methode (String), die dekoriert wurde.</li>\n<li><b>descriptor: </b>Ein Objekt mit zusätzlichen Informationen zur dekorierten Methode</li>\n</ul>"},{"type":"subheader","crDate":1754311039700,"chDate":1754311046134,"text":"Ablauf / Timing"},{"type":"paragraph","crDate":1754311038514,"chDate":1754312077928,"text":"Um einen Decorator wirklich zu verstehen muss zunächt verstanden werden, wie das Timing abläuft.\nDer Decorator wird ein einziges Mal aufgerufen, wenn das gewünschte Objekt mit der Klasse angelegt wird.\nEr enthält die eigentliche (a.k.a. die dekorierte) Methode in <i>descriptor.value</i>.\nWir wollen aber, dass noch zusätzlicher Code ausgeführt wird. Daher speichern wir die dekorierte Methode in eine <i>Intermediate Variable</i>.\nDann schreiben wir eine neue Funktion in descriptor.value.\nIn dieser Funktion wird der zusätzliche Code geschrieben und am Ende wird die Intermediate-Variable aufgerufen.\nDiese Funktion wird dann vom Decorator zurückgegeben.\nIn das von der Klasse erzeugte Objekt wird schließlich der Rückgabewert des Decorators eingetragen.\nDie Parameter werden vom <i>Rest-Parameter</i> namens <i>args</i> angenommen.\nDer Code in der Funktion wird aufgerufen und die Argumente an die dekorierte Methode weitergeleitet.\n"},{"type":"code","crDate":1754311103121,"chDate":1754311158828,"text":"const log = (target: any, methodName: string, descriptor: PropertyDescriptor) => {\n const originalMethod = descriptor.value;\n\n descriptor.value = (...args: any[]) => {\n  console.log(`Aufruf: ${methodName}(${args})`);\n  return originalMethod.apply(target, args);\n };\n\n return descriptor;\n};\n\nclass Rechner {\n @log\n addiere(a: number, b: number): number {\n  return a + b;\n }\n\n @log\n multipliziere(a: number, b: number): number {\n  return a * b;\n }\n}\n\nconst calc = new Rechner();\n\nlet result = calc.addiere(4, 5);\nconsole.log(result);\n\nresult = calc.multipliziere(4, 5);\nconsole.log(result);"},{"type":"subheader","crDate":1754309984651,"chDate":1754311032246,"text":"PropertyDescriptor"},{"type":"paragraph","crDate":1754310001402,"chDate":1754310338396,"text":"Der dritte Parameter des Decorators ist der Descriptor. Er ist vom Datentyp <i>PropertyDescriptor</i>.\nDieser enthält ein paar Informationen, um den Decorator zu beschreiben. Diese sind:\n<ul>\n<li><b>configurable:</b>Bestimmt, ob die Eigenschaft gelöscht oder ihre Attribute geändert werden können\n</li>\n<li><b>enumerable: </b>Bestimmt, ob die Eigenschaft in Schleifen (bspw. for-in) aufgelistet wird</li>\n<li><b>value: </b>Dieser Verweis auf die Methode wird verwendet, um im Decorator die Methode tatsächlich aufzurufen.</li>​\n<li><b>writable: </b>Bestimmt, ob die Eigenschaft überschreiben werden kann</li>\n</ul>"},{"type":"paragraph","crDate":1754308818553,"chDate":1754312332825,"text":"Decorators befinden sich übrigens auch in <i>Native Javascript</i> in Entwicklung und in einer der nächsten ECMA-Script Versionen dürfen wir diese erwarten.\nAußerdem steht für <i>Native JS</i> auch ein <a href=\"/?id=9wlsufi7lg8\">Code Pattern</a> zur Verfügung."}]}