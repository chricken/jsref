{"content":[{"type":"paragraph","crDate":1695300819623,"chDate":1695301552565,"text":"Das Scrolling ist in der Frontend-Entwicklung ausgesprochen wichtig.\nDas Beherrschen des Scrolling ermöglicht viele Techniken und Layout-Ideen:\n<ul>\n<li><b>Parallax Scrolling</b>\nVordergrund- und Hintergrundinhalte werden mit unterschiedlichen Geschwindigkeiten gescrollt. Dadurch entsteht die Illusion von Tiefe und verleiht der Website eine lebendige Wirkung.\n</li>\n<li><b>Endless Scrolling</b>\nEndless Scrolling, auch bekannt als Infinite Scrolling bedeutet, dass Inhalte automatisch nachgeladen werden, während der Benutzer nach unten scrollt.\n</li>\n<li><b>Scroll Animation</b>\nAnimationen auf der Webseite, die durch das Scrolling gesteuert werden. Dies ist ein wichtiger Bestandteit einer Storytelling-Webseite.\n</li>\n<li><b>Scroll-Tracking</b>\nErmöglicht es Webseitenbetreibern, das Scroll-Verhalten der Benutzer zu messen. Dadurch kann analysiert werden, wieviele und welche Inhalte vom Benutzer gesehen werden.\n</li>\n<li><b>Mehr</b>\nWie immer steht es jedem offen, eigene Techniken zu implementieren, indem die Möglichkeiten genutzt werden.\n</li>\n</ul>"},{"type":"subheader","crDate":1695301560236,"chDate":1695301587483,"text":"Auf Scrolling reagieren"},{"type":"paragraph","crDate":1695301582652,"chDate":1695301979254,"text":"Das scroll-Event reagiert auf das Scrollen des Benutzers. Der Event wird auch ausgelöst, wenn die Seite beim Laden automatisch an die vorherige Position springt.\n"},{"type":"code","crDate":1695301952960,"chDate":1695302001197,"text":"const handleScroll = () => {\n console.log('scrolling');\n}\n\nwindow.addEventListener('scroll', handleScroll);"},{"type":"subheader","crDate":1695302008893,"chDate":1695302016348,"text":"Scrollposition"},{"type":"paragraph","crDate":1695301705697,"chDate":1695302328829,"text":"Die Scrollposition kann auf verschiedene Weisen ausgelesen werden. In der Praxis ist es eine gute Idee, immer auf die gleiche Weise auf Informationen zuzugreifen. Daher hat sich die Verwendung von <i>document.documentElement.scrollTop</i> anstelle von window.scrollY durchgesetzt, auch wenn es mehr zu schreiben ist. Der Grund ist, dass die Eigenschaft scrollTop (und scrollLeft) auch in DOM-Elementen zu finden ist. So kann auch die Scrollposition von DOM-Elementen ausgelesen und verändert werden."},{"type":"code","crDate":1695302378706,"chDate":1695302386209,"text":"const handleScroll = () => {\n console.clear();\n console.log(document.documentElement.scrollTop);\n}\n\nwindow.addEventListener('scroll', handleScroll);"},{"type":"paragraph","crDate":1695302396521,"chDate":1695302660439,"text":"Wie oben beschrieben, kann diese Eigenschaft auch auf DOM-Elementen verwendet werden."},{"type":"code","crDate":1695302610007,"chDate":1695302712770,"text":"const handleScrollElement = evt => {\n console.clear();\n console.log(evt.target.scrollTop);\n}\n\ndocument.querySelector('.scrollable').addEventListener('scroll', handleScrollElement);\n            "},{"type":"subheader","crDate":1695302747656,"chDate":1695302754134,"text":"Relative Scrollposition"},{"type":"paragraph","crDate":1695302757886,"chDate":1695303242316,"text":"Damit ist gemeint, dass statt der Position in Pixel ein <i>Wert zwischen 0 und 1</i> ausgegeben wird. Dazu muss lediglich die aktuelle Scrollposition durch die gesamte Scrollhöhe dividiert werden.\nUm die maximale Scrollhöhe zu errechnen, wird einfach die Höhe des Viewports von der Höhe des Dokuemntes abgezogen."},{"type":"code","crDate":1695303278745,"chDate":1695303505234,"text":"const handleScroll = () => {\n console.clear();\n\n let scrollPos = document.documentElement.scrollTop;\n let scrollPosMax = document.documentElement.scrollHeight - document.documentElement.clientHeight;\n\n console.log(scrollPos / scrollPosMax);\n}\nwindow.addEventListener('scroll', handleScroll);"},{"type":"paragraph","crDate":1695303455485,"chDate":1695303472255,"text":"Wie zuvor kann auch diese Technik auf einzelne DOM-Elemente angewendet werden."},{"type":"code","crDate":1695303476451,"chDate":1695303499258,"text":"const handleScrollElement = evt => {\n console.clear();\n let scrollPos = evt.target.scrollTop;\n let scrollPosMax = evt.target.scrollHeight - evt.target.clientHeight;\n\n console.log(scrollPos / scrollPosMax);\n}\n\ndocument.querySelector('.scrollable').addEventListener('scroll', handleScrollElement);\n           "},{"type":"subheader","crDate":1695303524384,"chDate":1695303531871,"text":"Scrollposition ändern"},{"type":"paragraph","crDate":1695303535199,"chDate":1695305862156,"text":"Die Eigenschaften <i>scrollTop</i> und <i>scrollLeft</i> können auch überschrieben werden.\nDas ermöglicht eine sehr direkte Änderung der Scrollposition. \nIm Beispiel unten scrollt die Webseite bei jedem Klick an eine zufällige Position."},{"type":"code","crDate":1695305749803,"chDate":1695305882746,"text":"const handleClick = () => {\n let doc = document.documentElement;\n let max = doc.scrollHeight - doc.clientHeight;\n let rand = Math.round(Math.random() * max);\n doc.scrollTop = rand;\n}\ndocument.querySelector('#btnScroll').addEventListener('click', handleClick);"},{"type":"paragraph","crDate":1695305942598,"chDate":1695307086439,"text":"Neben dem direkten Beschreiben der Scrollposition kann auch die <i>scrollTo()</i>-Methode verwendet werden. \nDiese Methode kann entweder zwei Zahlen entgegennehmen, welche die X/Y-Koordinaten darstellen.\nOder die Methode bekommt ein Objekt übergeben, womit das Verhalten gesteuert wird. Das Objekt kann die folgenden Attribute enthalten:\n<ul>\n<li><b>top</b>\nGewünschte vertikale Scrollposition \n</li>\n<li><b>left</b>\nGewünschte horizontale Scrollposition \n</li>\n<li><b>behavior</b>\n<i>smooth</i> lässt den Bildschirm sanft scrollen\n<i>instant</i> lasst den Bildschirm an die Position springen\n<i>auto</i> steuert das Verhalten über CSS-Eigenschaft 'scroll-behavior'\nHinweis: Diese Angaben funktionieren nur unzuverlässig.\n</li>\n</ul>"},{"type":"code","crDate":1695307092108,"chDate":1695307141233,"text":"const handleClick = () => {\n let doc = document.documentElement;\n let max = doc.scrollHeight - doc.clientHeight;\n let rand = Math.round(Math.random() * max);\n\n document.documentElement.scrollTo({\n  top: rand,\n  behavior: 'smooth'\n });\n}\n\ndocument.querySelector('#btnScroll')\n .addEventListener('click', handleClick);"},{"type":"paragraph","crDate":1695307201924,"chDate":1695308189002,"text":"Die Methode <i>scrollBy()</i> scrollt <i>um</i> einen gegebenen Wert.\nDiese Methode kann entweder zwei Zahlen entgegennehmen, welche die X/Y-Koordinaten darstellen.\nOder die Methode bekommt ein Objekt übergeben, womit das Verhalten gesteuert wird. Das Objekt kann die folgenden Attribute enthalten:\n<ul>\n<li><b>top</b>\nGewünschte vertikale Scrollposition \n</li>\n<li><b>left</b>\nGewünschte horizontale Scrollposition \n</li>\n<li><b>behavior</b>\n<i>smooth</i> lässt den Bildschirm sanft scrollen\n<i>instant</i> lasst den Bildschirm an die Position springen\n<i>auto</i> steuert das Verhalten über CSS-Eigenschaft 'scroll-behavior'\nHinweis: Diese Angaben funktionieren nur unzuverlässig.\n</li>\n</ul>"},{"type":"code","crDate":1695308164327,"chDate":1695308216187,"text":"const handleClick = () => {\n let doc = document.documentElement;\n document.documentElement.scrollBy({\n  top: 100,  \n  behavior: 'smooth'\n });\n}\n\ndocument.querySelector('#btnScroll')\n .addEventListener('click', handleClick);"},{"type":"subheader","crDate":1695308331051,"chDate":1695308342330,"text":"Zu Element scrollen"},{"type":"paragraph","crDate":1695308349283,"chDate":1695309273095,"text":"Neben der reinen Manipulation der Scrollposition kann auch direkt zu einem bestimmten DOM-Element gescrollt werden.\nDazu wird zunächst das DOM-Element benötigt. Schließlich kann die <i>scrollIntoView()</i>-Methode aufgerufen werden.\nDie Methode versteht ein Options-Objekt, um das Verhalten zu steuern. Die möglichen Settings sind:\n<ul>\n<li><b>behavior</b>\n<i>smooth</i> lässt den Bildschirm sanft scrollen\n<i>instant</i> lasst den Bildschirm an die Position springen\n<i>auto</i> steuert das Verhalten über CSS-Eigenschaft 'scroll-behavior'\nHinweis: Diese Angaben funktionieren nur unzuverlässig.\n</li>\n<li><b>block</b>\nSteuert die vertikale Positionierung des Elementes.\n<i>start</i> Oberkante des Elementes scrollt an die Oberkante des Viewport.\n<i>center</i> Mitte des Elementes scrollt an die Mitte des Viewport.\n<i>end</i> Unterkante des Elementes scrollt an die Unterkante des Viewport.\n<i>nearest</i> Wählt automatisch den Wert von oben, der am dichtesten ist.\nHinweis: Diese Angaben funktionieren nur unzuverlässig.\n</li>\n<li>\n<b>inline</b>\nSteuert die horizontale Positionierung des Elementes.\nDie Optionen sind dieselben wie bei block.\n</li>\n</ul>"},{"type":"code","crDate":1695309297654,"chDate":1695309372040,"text":"const handleClick = () => {\n const el = document.querySelector('#scrollHere');\n el.scrollIntoView({\n  behavior: 'smooth'\n });\n}\n\ndocument.querySelector('#btnScroll')\n .addEventListener('click', handleClick);"},{"type":"subheader","crDate":1695301692756,"chDate":1695301698946,"text":"smooth-scrolling"}]}