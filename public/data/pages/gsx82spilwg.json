{"content":[{"type":"paragraph","crDate":1693222480860,"chDate":1715951033370,"text":"Proxies bieten die Möglichkeit, bei Zugriffen auf ein Objektattribut zusätzlichen Code auszuführen.\nAußerdem kann über den Proxy gesteuert werden, ob Attribute überhaupt gelesen bzw. beschrieben werden können.\nHäufige Einsatzzwecke für einen Proxy sind, :\n<ul><li>Loggen</li>\n<li>Validieren</li>\n<li>Formatieren</li>\n<li>Bereinigen</li>\n<li>Anonymisieren</li>\n<li>etc.</li>\n</ul>Ein Proxy wird über den in JS mitgelieferten <i>Proxy()</i>-Constructor umgesetzt.\nDer Proxy-Constructor bekommt zwei Parameter übergeben: Das gesteuerte Objekt (<i>target</i>) und ein Objekt mit Handlern (a.k.a. <i>Traps</i>), die auf die verschiedenen Zugriffe reagieren. Hier die wichtigsten:\n<ul>\n<li><b>get()</b>: Lesezugriff auf ein Attribut</li>\n<li><b>.set()</b>: Schreibzugriff auf ein Attribut</li>\n<li><b>apply()</b>: Aufruf der Funktion (Nur, wenn der Proxy auf eine Funktion angewendet wurde)</li>\n<li><b>defineProperty()</b>: Anlegen eines neuen Attributes</li>\n<li><b>deleteProperty()</b>: Entfernen eines Attributes</li>\n</ul>\n<b>Achtung:</b> Jede der Methoden muss einen Return zurückgeben, der nicht <i>false</i>."},{"type":"paragraph","crDate":1715949409785,"chDate":1715949493466,"text":"Im Beispiel wird der Zugriff auf ein Objekt über einen Proxy geregelt. \nBeim Lesen eines Wertes wird dieser Zugriff geloggt.\nBeim Schreiben eines Wertes wird zusätzlich sichergestellt, dass der Wert vom richtigen Datentypen ist."},{"type":"code","crDate":1715949497725,"chDate":1715951830041,"text":"const proxyAuto = new Proxy(myCar, {\n get(target, prop) {\n  console.log(`abgefragte Daten: ${prop}`);\n  return target[prop];\n },\n set(target, prop, newVal) {\n  console.log(`geänderte Daten: ${prop} -> ${newVal}`);\n  if (prop.includes('leistung')) newVal = Number(newVal);\n  else newVal = String(newVal);\n  target[prop] = newVal;\n  return true;\n },\n deleteProperty(target, key){\n  console.log(`Gelöschte Daten: ${key}`);\n  return true\n }\n})\n\nconsole.log(proxyAuto.modell);\n\nproxyAuto.modell = 'i30';\nproxyAuto.leistungKW = '100';\ndelete proxyAuto.baujahr;\n\nconsole.log(proxyAuto.modell);\nconsole.log(typeof proxyAuto.leistungKW, proxyAuto.leistungKW);\n\nconsole.log(proxyAuto.alter());"},{"type":"subheader","crDate":1715952710592,"chDate":1715952722141,"text":"Proxy-Klasse"},{"type":"paragraph","crDate":1715952724994,"chDate":1715953453651,"text":"In einem Modul kann eine Struktur erzeugt werden, in der die Klasse sowie das erzeugte Objekt versteckt sind und die nur den <i>Proxy</i> zurückgibt.\nDas Modul gibt eine Funktion zurück, in welches das neue Objekt erzeugt wird. Durch das Scope in JS kann auf das Objekt nicht zugegriffen werden.\nDieses Objekt gibt dann den Proxy zurück."},{"type":"code","crDate":1715953194698,"chDate":1715953273588,"text":"// Modul Car.js\n\nclass Car {\n constructor(marke, modell, leistungKW, baujahr) {\n  Object.assign(this, {\n   marke, modell, leistungKW, baujahr\n  })\n }\n alter() {\n  return new Date().getFullYear() - this.baujahr;\n }\n}\n\nexport default (marke, modell, leistungKW, baujahr) => {\n let car = new Car(marke, modell, leistungKW, baujahr);\n\n return new Proxy(car, {\n  get(target, prop) {\n   console.log(`abgefragte Daten: ${prop}`);\n   return target[prop]\n  },\n  set(target, prop, newVal) {\n   console.log(`geänderte Daten: ${prop} -> ${newVal}`);\n   target[prop] = newVal;\n   return true;\n  }\n })\n}"},{"type":"code","crDate":1715953216668,"chDate":1715953236652,"text":"// index.js\n\nimport Car from './Car.js';\n\nconst myCar = Car('VW', 'id3', 100, 2022);\nconst yourCar = Car('Opel', 'Astra', 120, 2020);\n\nconsole.log(myCar.modell);\nconsole.log(yourCar.modell);\n\nmyCar.modell = 'i30';"}]}