{"content":[{"type":"paragraph","crDate":1706102121507,"chDate":1708527669321,"text":"Im Folgenden bauen wir als Beispiel ein eigenes <i>modales Alert-Fenster</i> auf, das durch Parameter gesteuert werden kann.\nDas modale Alert-Fenster soll auf einem abgedunkelten Hintergrund liegen, einen Container für Texte enthalten sowie einen Button, um die Nachricht zu schließen."},{"type":"subheader","crDate":1706109897843,"chDate":1706109900268,"text":"Basis"},{"type":"paragraph","crDate":1706109320073,"chDate":1706109873061,"text":"Wir beginnen mit der grundlegenden Integration des Custom Elements. \nMit der Klasse wird das HTML-Element erzeugt.\nIn der <i>constructor()</i>-Methode wird der das ShadowDOM eingehängt. Der mode \nUnd das Custom Element wird mit einem Namen (<i>mit Bindestrich</I>) definiert.\nDer <i>mode</i> definiert, ob die Komponente im Browser durchsucht werden kann."},{"type":"code","crDate":1706109213938,"chDate":1706109755526,"text":"class ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })        \n }   \n}\n\ncustomElements.define('modal-alert', ModalAlert);\n"},{"type":"subheader","crDate":1706109889102,"chDate":1706109893867,"text":"Template"},{"type":"paragraph","crDate":1706109919450,"chDate":1708523689346,"text":"Das Template ist ein HTML-Baum, der die Struktur der Komponente definiert.\nWie die HTML-Struktur angelegt wird, ist zweitrangig. Es kann ein Eltern-Element sein, in den per innerHTML der gesamte HTML-Code für die Children eingehängt wird.\nEs kann mit den Standard-Werkzeugen DOM-Elemente erzeugt und verschachtelt werden. Oder ein beliebiger anderer Weg.\nDas Template kann natürlich auch aus einem Modul <i>importiert</i> werden, um den Code in der Web Component zu vereinfachen. Dies ist im Beispiel zu sehen."},{"type":"paragraph","crDate":1708526904709,"chDate":1708527063122,"text":"Im Template ist auch ein &lt;slot>-Element eingefügt. \nDieses wird durch den String ersetzt, der im HTML-Element steht."},{"type":"code","crDate":1708523696241,"chDate":1708526862021,"text":"const template = document.createElement('div');\ntemplate.className = 'modalBG';\n\nconst container = document.createElement('div');\ncontainer.className = 'container';\ntemplate.append(container);\n\nconst elContent = document.createElement('div');\nelContent.className = 'content';\nelContent.innerHTML = 'Hallo Welt';\ncontainer.append(elContent);\n\nconst elSlot = document.createElement('slot');\nelContent.append(elSlot)\n\nconst btnClose = document.createElement('button');\nbtnClose.className = 'btnClose';\nbtnClose.innerHTML = 'Close';\ncontainer.append(btnClose);\n\nexport default template;"},{"type":"paragraph","crDate":1706182224815,"chDate":1708526824768,"text":"Eine Kopie dieses Templates wird dann im Shadow DOM eingehängt.\nEs ist wichtig zu verstehen, dass die Komponente eine <i>Kopie</i> des Template ist.\nDas heißt, dass die im Template erzeugten Variablen (container, elContent, etc.) nicht angesprochen werden können, um den Inhalt der Komponenten zu verändern. Vielmehr muss zur Laufzeit aus der Komponente das gewünschte Kind per <i>querySelector()</i> gesucht werden."},{"type":"code","crDate":1706110254066,"chDate":1708524632011,"text":"import template from \"./template.js\";\n\nclass ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })\n  \n  this.root.append(template.cloneNode(true));\n  const btn = this.root.querySelector('.btnClose');\n  btn.addEventListener('click', () => this.remove());\n }\n}\n\ncustomElements.define('modal-alert', ModalAlert);\n"},{"type":"subheader","crDate":1706182647752,"chDate":1706182668430,"text":"CSS"},{"type":"paragraph","crDate":1706182671006,"chDate":1708525389241,"text":"Das Styling des Elementes soll nicht von außen beeinflusst werden und soll auch nicht andere Komponenten beeinflussen. Darum kümmert sich das ShadowDOM, das weiter oben bereits eingebunden wurde.\nAllerdings muss für diese Komponente auch ein Styling hinterlegt werden. Das wird am besten über einen <i>style</i>-Tag erledigt, der in das Template eingebunden wird. Um mit dem CSS-Code nicht das eigene Template zu überfrachten, empfiehlt sich die Einbindung einer CSS-Datei per <i>@import</i>. \nEine Schwierigkeit dabei ist der <i>Pfad</i> zur CSS-Datei, da diese vom <i>HTML-Dokument</i> aus definiert werden muss. Den Pfad absolut zu definieren (/assets/components/...) würde bedeuten, diesen bei jedem Kopiervorgang anpassen zu müssen. Da ein relativer Pfad nicht einfach definiert werden kann, muss dieser basierend auf dem aktuellen Pfad ermittelt werden."},{"type":"code","crDate":1706183048226,"chDate":1708525356446,"text":"const template = document.createElement('div');\ntemplate.className = 'modalBG';\n\n// Pfad der aktuellen Datei\nlet path = new URL(import.meta.url).pathname;\n// Entfernen des alten und Anhängen des neuen Dateinamens\npath = `${path.substring(0, path.lastIndexOf('/') + 1)}styles.css`;\n\n// style-Tag einsetzen\nconst elStyle = document.createElement('style');\n// Import der CSS-Datei\nelStyle.innerHTML = `@import \"${path}\"`;\ntemplate.append(elStyle);"},{"type":"paragraph","crDate":1708526379489,"chDate":1708526526534,"text":"Die Datei styles.css muss im selben Ordner liegen wie das Template, damit der Code oben funktioniert."},{"type":"code","crDate":1708526258222,"chDate":1708526332804,"text":".modalBG {\n position: fixed;\n display: flex;\n justify-content: center;\n align-items: center;\n left: 0;\n top: 0;\n right: 0;\n bottom: 0;\n background-color: rgba(0, 0, 0, .6);\n}\n\n.container {\n position: relative;\n width:30%;\n min-height:30%;\n background-color: #fff;\n border: 2px solid #ccc;\n padding:20px;\n border-radius: 5px;\n}\n\n.content {}\n\n.btnClose {\n position: absolute;\n bottom:10px;\n width:100px;\n left: 50%;\n transform: translateX(-50px);\n}"},{"type":"subheader","crDate":1708527718469,"chDate":1708527723756,"text":"Close-Event"},{"type":"paragraph","crDate":1708527713845,"chDate":1708528306097,"text":"Schließlich soll das modale Alert-Fenster noch einen Event liefern, sodass auf das Schließen des Fensters reagiert werden kann.\nDazu wird in der <i>connectedCallback()</i>-Methode ein <i>customEvent</i> angelegt und bei Click des Buttons ausgelöst. Der customEvent-Constructor hat als Event-Namen <i>closed</i> bekommen. Über diesen Eventnamen kann auf das Event reagiert werden (s.u.)"},{"type":"code","crDate":1708528038764,"chDate":1708528117118,"text":"class ModalAlert extends HTMLElement {\n ...\n\n connectedCallback() {\n  const btn = this.root.querySelector('.btnClose');\n\n  const myEvent = new CustomEvent('closed', {\n   detail: { text: 'Hello' }\n  })\n\n  btn.addEventListener('click', () => {\n   this.dispatchEvent(myEvent);\n  })\n }\n}"},{"type":"paragraph","crDate":1708528130198,"chDate":1708528173272,"text":"Dem HTML-Element kann nun ein zu dem Event passender <i>Handler</i> zugewiesen werden."},{"type":"code","crDate":1708528176397,"chDate":1708528197793,"text":"const el = document.querySelector('modal-alert');\n\nel.addEventListener('closed', evt => {\n console.log(evt);\n})"}]}