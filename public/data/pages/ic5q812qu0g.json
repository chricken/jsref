{"content":[{"type":"paragraph","crDate":1706102121507,"chDate":1706109209471,"text":"Im Folgenden bauen wir als Beispiel ein eigenes modales Alert-Fenster auf, das durch Parameter gesteuert werden kann.\nDas modale Alert-Fenster soll auf einem abgedunkelten Hintergrund liegen, einen Container für Texte enthalten sowie einen Button, um die Nachricht zu schließen."},{"type":"subheader","crDate":1706109897843,"chDate":1706109900268,"text":"Basis"},{"type":"paragraph","crDate":1706109320073,"chDate":1706109873061,"text":"Wir beginnen mit der grundlegenden Integration des Custom Elements. \nMit der Klasse wird das HTML-Element erzeugt.\nIn der <i>constructor()</i>-Methode wird der das ShadowDOM eingehängt. Der mode \nUnd das Custom Element wird mit einem Namen (<i>mit Bindestrich</I>) definiert.\nDer <i>mode</i> definiert, ob die Komponente im Browser durchsucht werden kann."},{"type":"code","crDate":1706109213938,"chDate":1706109755526,"text":"class ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })        \n }   \n}\n\ncustomElements.define('modal-alert', ModalAlert);\n"},{"type":"subheader","crDate":1706109889102,"chDate":1706109893867,"text":"Template"},{"type":"paragraph","crDate":1706109919450,"chDate":1706110654730,"text":"Das Template ist ein HTML-Baum, der die Struktur der Komponente definiert.\nWie die HTML-Struktur angelegt wird, ist zweitrangig. Es kann ein Eltern-Element sein, in den per innerHTML der gesamte HTML-Code für die Children eingehängt wird.\nEs kann mit den Standard-Werzeugen DOM-Elemente erzeugt und verschachtelt werden. Oder ein beliebiger anderer Weg.\nDas Template kann natürlich auch aus einem Modul <i>importiert</i> werden, um den Code in der Web Component zu vereinfachen.\nEine Kopie dieses Templates wird dann in im Shadow DOM eingehängt.\nEs ist wichtig zu verstehen, dass die Komponente eine Kopie des Template ist. Das heißt, dass der Inhalt der Komponenten, die auf der Webseite zu sehen ist, nicht über die Variablen \".container\", \".elContent\", etc verändert werden kann. Vielmehr muss zur Laufzeit aus der Komponenten das gewünschte Kind per <i>querySelector()</i> gesucht werden.\nDas gilt auch für Eventlistener. Listener, die dem Template gegeben wurden, haben keine Wirkung. Ein Eventlistener muss im <i>constructor()</i> angelegt werden, damit die Kopie des Buttons ihn erhält."},{"type":"code","crDate":1706110254066,"chDate":1706110718302,"text":"const template = document.createElement('div');\ntemplate.className = 'modalBG';\n\nconst container = document.createElement('div');\ncontainer.className = 'container';\ntemplate.append(container);\n\nconst elContent = document.createElement('div');\nelContent.className = 'content';\ncontainer.append(elContent);\n\nconst btnClose = document.createElement('button');\nbtnClose.className = 'btnClose';\nbtnClose.innerHTML = 'Close';\ncontainer.append(btnClose);\n\n\nclass ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })\n  this.root.append(template.cloneNode(true));\n  const btn = this.root.querySelector('.btnClose');\n  btn.addEventListener('click', () => this.removeEl());\n }\n // Entfernen\n removeEl() {\n  this.remove();\n }\n}\n\ncustomElements.define('modal-alert', ModalAlert);"}]}