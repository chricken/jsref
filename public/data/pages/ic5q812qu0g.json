{"content":[{"type":"paragraph","crDate":1706102121507,"chDate":1706109209471,"text":"Im Folgenden bauen wir als Beispiel ein eigenes modales Alert-Fenster auf, das durch Parameter gesteuert werden kann.\nDas modale Alert-Fenster soll auf einem abgedunkelten Hintergrund liegen, einen Container für Texte enthalten sowie einen Button, um die Nachricht zu schließen."},{"type":"subheader","crDate":1706109897843,"chDate":1706109900268,"text":"Basis"},{"type":"paragraph","crDate":1706109320073,"chDate":1706109873061,"text":"Wir beginnen mit der grundlegenden Integration des Custom Elements. \nMit der Klasse wird das HTML-Element erzeugt.\nIn der <i>constructor()</i>-Methode wird der das ShadowDOM eingehängt. Der mode \nUnd das Custom Element wird mit einem Namen (<i>mit Bindestrich</I>) definiert.\nDer <i>mode</i> definiert, ob die Komponente im Browser durchsucht werden kann."},{"type":"code","crDate":1706109213938,"chDate":1706109755526,"text":"class ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })        \n }   \n}\n\ncustomElements.define('modal-alert', ModalAlert);\n"},{"type":"subheader","crDate":1706109889102,"chDate":1706109893867,"text":"Template"},{"type":"paragraph","crDate":1706109919450,"chDate":1706182350943,"text":"Das Template ist ein HTML-Baum, der die Struktur der Komponente definiert.\nWie die HTML-Struktur angelegt wird, ist zweitrangig. Es kann ein Eltern-Element sein, in den per innerHTML der gesamte HTML-Code für die Children eingehängt wird.\nEs kann mit den Standard-Werzeugen DOM-Elemente erzeugt und verschachtelt werden. Oder ein beliebiger anderer Weg.\nDas Template kann natürlich auch aus einem Modul <i>importiert</i> werden, um den Code in der Web Component zu vereinfachen."},{"type":"paragraph","crDate":1706182224815,"chDate":1706182600011,"text":"Eine Kopie dieses Templates wird dann im Shadow DOM eingehängt.\nEs ist wichtig zu verstehen, dass die Komponente eine Kopie des Template ist. Das heißt, dass der Inhalt der Komponenten, die auf der Webseite zu sehen ist, nicht über die Variablen \".container\", \".elContent\", etc verändert werden kann. Vielmehr muss zur Laufzeit aus der Komponenten das gewünschte Kind per <i>querySelector()</i> gesucht werden.\nDas gilt auch für Eventlistener. Listener, die dem Template gegeben wurden, haben keine Wirkung. Ein Eventlistener muss im <i>constructor()</i> angelegt werden, damit die Kopie des Buttons ihn erhält."},{"type":"code","crDate":1706110254066,"chDate":1706182633706,"text":"const template = document.createElement('div');\ntemplate.className = 'modalBG';\n\nconst container = document.createElement('div');\ncontainer.className = 'container';\ntemplate.append(container);\n\nconst elContent = document.createElement('div');\nelContent.className = 'content';\ncontainer.append(elContent);\n\nconst btnClose = document.createElement('button');\nbtnClose.className = 'btnClose';\nbtnClose.innerHTML = 'Close';\ncontainer.append(btnClose);\n\nclass ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })\n  this.root.append(template.cloneNode(true));\n  const btn = this.root.querySelector('.btnClose');\n  btn.addEventListener('click', () => this.removeEl());\n }\n // Entfernen\n removeEl() {\n  this.remove();\n }\n}\n\ncustomElements.define('modal-alert', ModalAlert);"},{"type":"subheader","crDate":1706182647752,"chDate":1706182668430,"text":"CSS"},{"type":"paragraph","crDate":1706182671006,"chDate":1706183033659,"text":"Das Styling des Elementes soll nicht von außen beeinflusst werden und soll auch nicht andere Komponenten beeinflussen. Darum kümmert sich das ShadowDOM, das weiter oben bereits eingebunden wurde.\nAllerdings muss nun noch für diese Komponente Styling hinterlegt werden. Das wird am besten über einen <i>style</i>-Tag erledigt, der in das Template eingebunden wird. Um mit dem CSS-Code nicht das eigene Template zu überfrachten, empfiehlt sich die Einbindung einer CSS-Datei per <i>@import</i>. Die CSS-Datei sollte sich im selben Unterordner befinden wie die JS-Datei und nur das Styling dieser Komponenten enthalten."},{"type":"code","crDate":1706183048226,"chDate":1706183067492,"text":"const template = document.createElement('div');\ntemplate.className = 'modalBG';\ntemplate.innerHTML = '<style>@import \"/assets/components/ModalAlert/ModalAlert.css\"</style>';\n"},{"type":"subheader","crDate":1706186906059,"chDate":1706187021779,"text":"Parameter (String)"},{"type":"paragraph","crDate":1706187011160,"chDate":1706188544062,"text":"In HTML können Parameter eigentlich nur als String übergeben werden. Diese Parameter werden in der Web Component vorbereitet und können dann einfach auf die übliche Weise übergeben werden.\nIn der Web Component muss aber einiges bedacht werden:\n<ul>\n<li>Das erwartete Attribut muss bekannt gegeben werden, damit die Komponente damit arbeiten kann. Das wird über die statische <i>observedAttributes()</i>-Methode erledigt. Diese liefert ein Array zurück mit den Namen der erwarteten Attribute.</li>\n<li>Damit der Parameter dann auch im gerenderten DOM-Element arbeitet, braucht es einen <i>Getter</i> und einen <i>Setter</i>, um das Attribut einzutragen bzw. dessen Value zu lesen.</li>\n<li>Eine Änderung des Attributes muss auch berücksichtigt werden. Dafür wird die <i>attributeChangedCallback()</i>-Methode benötigt.. Diese wird bei jeder Änderung eines Attributes aufgerufen. Es bekommt als Parameter den Attributnamen, den bisherigen Wert und den aktuellen Wert. Diese Informationen können dann passend verarbeitet werden.\nBeachte bitte, dass die Methode initial immer einmal aufgerufen wird.</li>\n</ul>"},{"type":"code","crDate":1706188567517,"chDate":1706188662765,"text":"const template = document.createElement('div');\n// ...\n\nclass ModalAlert extends HTMLElement {\n    // ...\n\n    // Erwartete String-Attribute\n    static get observedAttributes() {\n        return ['content', 'btncontent']\n    }\n\n    // Getter und Setter für String-Attribute\n    get 'content'() {\n        return this.getAttribute('content')\n    }\n    set 'content'(val) {\n        this.setAttribute('content', val);\n    }\n\n    get 'btncontent'() {\n        return this.getAttribute('btncontent')\n    }\n    set 'btncontent'(val) {\n        this.setAttribute('btncontent', val);\n    }\n\n    // Eventlistener für veränderte Attribute\n    attributeChangedCallback(attrName, oldVal, currentVal) {\n        // switch bietet kein eigenes Scope.\n        let el;\n        switch (attrName) {\n            case 'content':\n                el = this.root.querySelector('.content');\n                el.innerHTML = currentVal\n                break;\n            case 'btncontent':\n                el = this.root.querySelector('button.btnClose');\n                el.innerHTML = currentVal\n                break;\n            default:\n                break;\n        }\n    }\n}\n\n// ...\n"},{"type":"subheader","crDate":1706188699643,"chDate":1706188709194,"text":"Parameter (non-String)"},{"type":"paragraph","crDate":1706188713274,"chDate":1706192574753,"text":"Da ein HTML-Element ausschließlich Strings übertragen kann, können wir weder Objekte, noch Funktionen, Zahlen oder etwas anderes direkt übergeben. Daher braucht es einen besseren Weg.\nEine guter Weg ist eine <i>Methode</i> in der Web Component. Diese Methode kann beliebige Parameter annehmen, auch Objekte oder Funktionen. \nDas hat zur Folge, dass non-String-Parameter nachträglich durch den <i>Aufruf der Methode</i> hinzugefügt werden müssen, ganz ähnlich wie Eventlistener.\nHinweis: Im Beispiel werden <i>Named Arguments</i> verwendet, um das Handling zu erleichtern."},{"type":"code","crDate":1706193312537,"chDate":1706193815595,"text":"// Die gesamte Web Component\n'use strict';\n\nconst template = document.createElement('div');\ntemplate.className = 'modalBG';\ntemplate.innerHTML = `\n&lt;style>@import \"/assets/components/ModalAlert/ModalAlert.css\"&lt;/style>\n`;\n\nconst container = document.createElement('div');\ncontainer.className = 'container';\ntemplate.append(container);\n\nconst elContent = document.createElement('div');\nelContent.className = 'content';\ncontainer.append(elContent);\n\nconst btnClose = document.createElement('button');\nbtnClose.className = 'btnClose';\nbtnClose.innerHTML = 'Close';\ncontainer.append(btnClose);\n\n\nclass ModalAlert extends HTMLElement {\n constructor() {\n  super();\n  this.root = this.attachShadow({\n   mode: 'closed'\n  })\n  this.root.append(template.cloneNode(true));\n  this.root.className = 'container';\n\n  this.btn = this.root.querySelector('.btnClose');\n  this.btn.addEventListener('click', () => this.removeEl())\n\n }\n\n // Übertragen der non-String-Attribute\n setOptions({\n  callback\n }) {\n  if (callback) {\n   this.btn.addEventListener('click', callback);\n  }\n }\n\n // Erwartete String-Attribute\n static get observedAttributes() {\n  return ['content', 'btncontent']\n }\n\n // Getter und Setter für String-Attribute\n get 'content'() {\n  return this.getAttribute('content')\n }\n set 'content'(val) {\n  this.setAttribute('content', val);\n }\n get 'btncontent'() {\n  return this.getAttribute('btncontent')\n }\n set 'btncontent'(val) {\n  this.setAttribute('btncontent', val);\n }\n\n // Eventlistener für veränderte Attribute\n attributeChangedCallback(attrName, oldVal, currentVal) {\n  let el;\n  switch (attrName) {\n   case 'content':\n    el = this.root.querySelector('.content');\n    el.innerHTML = currentVal\n    break;\n   case 'btncontent':\n    el = this.root.querySelector('button.btnClose');\n    el.innerHTML = currentVal\n   break;\n   default:\n   break;\n  }\n\n }\n\n // Entfernen\n removeEl() {\n  this.remove();\n }\n\n}\n\ncustomElements.define('modal-alert', ModalAlert);"},{"type":"code","crDate":1706193395484,"chDate":1706193735808,"text":"// Einbinden der Web Component\n\nconst alertHandler = () => {\n console.log('Eine eigene Callback-Funktion');\n}\n\nconst alert = document.createElement('modal-alert');\nalert.content = 'Hallo, dies ist ein Alert-Fenster.';\nalert.btncontent = 'Sofort schließen';\nalert.setOptions({\n callback: alertHandler\n})\ndocument.body.append(alert);"}]}